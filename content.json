{"meta":{"title":"Linik's Blog","subtitle":"","description":"A personal blog","author":"Linik","url":"https://linikc.github.io","root":"/"},"pages":[{"title":"","date":"2024-02-16T09:44:23.771Z","updated":"2024-02-16T09:44:23.771Z","comments":true,"path":"about/index.html","permalink":"https://linikc.github.io/about/index.html","excerpt":"","text":"About myselfJust a student from China.I have nothing special. I am just an ordinary person."},{"title":"","date":"2023-12-22T14:17:41.668Z","updated":"2023-12-22T14:17:41.668Z","comments":true,"path":"404.html","permalink":"https://linikc.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-07-06T10:48:58.117Z","updated":"2024-07-06T10:48:58.117Z","comments":true,"path":"faq/index.html","permalink":"https://linikc.github.io/faq/index.html","excerpt":"","text":"FAQUntil now, we don’t have any problem Some Problems in our daily life1.百度同步空间图标删除regedit：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace找到有关同步空间的目录删掉，只有一项,为REG_SZ类型，可用查找搜索“同步空间”or 需要在边栏同步那先开启同步然后关闭同步就会消失"},{"title":"","date":"2023-12-17T07:25:55.421Z","updated":"2023-12-17T07:25:55.421Z","comments":true,"path":"mylist/index.html","permalink":"https://linikc.github.io/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2024-01-20T08:43:46.670Z","updated":"2024-01-20T08:43:46.670Z","comments":true,"path":"chat/index.html","permalink":"https://linikc.github.io/chat/index.html","excerpt":"","text":"Chat"},{"title":"所有分类","date":"2023-12-17T07:25:34.116Z","updated":"2023-12-17T07:25:34.116Z","comments":true,"path":"categories/index.html","permalink":"https://linikc.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-12-17T07:26:35.101Z","updated":"2023-12-17T07:26:35.101Z","comments":true,"path":"tags/index.html","permalink":"https://linikc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Win32 Start","slug":"Win32-start","date":"2024-07-28T05:39:20.000Z","updated":"2024-07-28T08:23:19.947Z","comments":true,"path":"2024/07/28/Win32-start/","link":"","permalink":"https://linikc.github.io/2024/07/28/Win32-start/","excerpt":"","text":"Win32 StartIntroductionWin32 是 Windows 操作系统提供的应用程序接口（API），它允许开发人员使用 C&#x2F;C++ 编程语言创建 Windows 应用程序。Win32 API 提供了大量的函数和宏，用于处理窗口、图形、文件操作、网络通信等任务。AI真厉害简而言之，就是为创建Windows应用窗口提供了一个便捷的官方的方法虽然还是有点复杂话不多说，直接开始 声明全程用的是Unicode字符集，故字符串前要加上”L“不然乱码 WinMainWinMain()是整个程序的入口点，相当于我们一般写的main()。相较于main来说，WinMain的参数变多，且必须要填 12345#include &lt;windows.h&gt;int WINAPI WinMain( HINSTANCE hInstace,HINSTANCE hPrevInstance, LPSTR lpCmdLine,int nCmdShow) 我们来分析以上代码 HISTANCE hInstancehInstance h即handle 句柄&#x2F;处理 的意思Instance 例子&#x2F;实例的意思，故为实例句柄 Handle Instance计算机用来识别EXE文件身份的值 HINSTANCE hPrevInstancehPrevInstance Prev 即Previous 先前的故为先前实例句柄 Handle Previous Instance如果打开两个该EXE文件，那么第一个窗口是后者的先前实例句柄始终为NULL LPSTR lpCmdLine L Long P Pointer(指针) STR string指向一个字符串的32位指针，每个字符占1个字节,解释不下去了，用Microsoft原话:应用程序的命令行，不包括程序名称 int nCmdShow n即int类似还有b bool, c cahr ,s string , p pointer Microsoft:如果函数成功，在收到 WM_QUIT 消息时终止，它应返回该消息 wParam 参数中包含的退出值。 如果函数在输入消息循环之前终止，则应返回零OK舒一口气~继续 WNDCLASSEXWNDCLASSEX 看名字CLASS,OK 结构体，WND Window ,EX Extended 扩展的，故为窗口类扩展结构体 人话:窗口类初始化设置 1234567891011121314typedef struct tagWNDCLASSEX &#123; UINT cbSize; // 结构体大小 UINT style; // 窗口类样式 WNDPROC lpfnWndProc; // 窗口过程函数 int cbClsExtra; // 窗口类附加内存 int cbWndExtra; // 窗口附加内存 HINSTANCE hInstance; // 窗口类实例句柄 HICON hIcon; // 窗口类图标 HCURSOR hCursor; // 窗口类光标 HBRUSH hbrBackground; // 窗口类背景画刷 LPCTSTR lpszMenuName; // 窗口类菜单名称 LPCTSTR lpszClassName; // 窗口类名称 HICON hIconSm; // 窗口类小图标&#125; ... 看看定义稍微写写 12345678910111213WNDCLASSEX wc;//不是w cwc.cbSize = sizeof(WNDCLASSEX);//结构体大小wc.style = CS_HREDRAW | CS_VREDRAW;//窗口类样式 0也可以 CS 不是 WS 下面会讲wc.lpfnWndProc = WndProc;//窗口过程函数 后面说不要急wc.cbClsExtra = 0;//窗口类附加内存 一般为0同下wc.cbWndExtra = 0;//窗口附加内存wc.hInstance = hInstance;//窗口类实例句柄wc.hIcon = LoadIcon(NULL,IDI_APPLICATION);//窗口类图标 默认的那个wc.hCursor = LoadCursor(NULL,IDC_ARROW);//窗口类光标 自己的光标了wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);//窗口类背景画刷 白色 HBRUSH HB? Brush? 还是 Hard Brush? 不知道wc.hIconSm = LoadIcon(NULL,IDI_APPLICATION);//窗口类小图标wc.lpszMenuName = NULL;//窗口类菜单名称wc.lpszClassName = L&quot;Win32&quot;;//窗口类名称 窗口类名称可以用全局变量 1const wchar_t g_classWName[] = L&quot;MYFWINDOWS&quot;; 破案了 LPSTR 是 const wchar_t* Register注册窗口类 12345if(!RegisterClassEx(&amp;wc))&#123; MessageBox(NULL,L&quot;窗口类注册失败 | Window Resgister Failed&quot;,L&quot;错误 | WRONG&quot;,MB_ICONEXCLAMATION|MB_OK); return 0;&#125; MessageBox 玩过VBS的应该知道这是显示一个消息框（弹窗）MB_ICONEXCLAMATION 是感叹号图标，MB_OK 是确定按钮让我设置好Hexo的图片显示再给图（帮我记着） Create创建窗口 123456789HWND hWnd;hwnd = CreateWindowEx( 0, g_classWName,//L&quot;Win32&quot;,也行 L&quot;Win32&quot;, WS_OVERLAPPEDWINDOW,//WS_OVERLAPPEDWINDOW是一个窗口式样参数 WS CW_USEDEFAULT,CW_USEDEFAULT,500,400,//x,y,w,h CW_USEDEFAULT 使用默认 4个都可以 NULL,NULL,hInstance,NULL); 来来，定义来咯~ 12345678910111213CreateWindowExW( _In_ DWORD dwExStyle,//WS_EX_CLIENTEDGE 与 0 不知道有什么区别 _In_opt_ LPCWSTR lpClassName, _In_opt_ LPCWSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent,//父级窗口，没有，因为我就是父--级,开玩笑 _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);//窗口的创建数据 记得Check 123456if (hwnd == NULL)&#123; MessageBox(NULL, L&quot;窗口创建失败 | Window Creation Failed!&quot;, L&quot;错误 | Error!&quot;, MB_ICONEXCLAMATION | MB_OK); return 0; &#125; Show显示窗口 12ShowWindow(hWnd,nCmdShow);//nCmdShow 可选参数 我会在之后把一些函数的参数整理一下UpdateWindow(hWnd); Message消息部分补上开头的WndProc 123456789101112131415LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)//l 可以理解为local&#123; switch (message) &#123; case WM_CLOSE: DestroyWindow(hWnd); break; case WM_DESTROY:PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125; Run运行消息循环 1234567MSG msg;while (GetMessage(&amp;msg, NULL, 0, 0))//任何事件会产生一个消息并推送到消息队列，那么GetMessage&#123; TranslateMessage(&amp;msg);// TranslateMessage 将消息转换为字符消息 翻译 DispatchMessage(&amp;msg);//dispatch 发送 DispatchMessage(&amp;msg);//dispatch 发送&#125; End1return (int)msg.wParam; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;windows.h&gt;const wchar_t g_classWName[] = L&quot;MYFWINDOWS&quot;;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_CLOSE: DestroyWindow(hWnd); break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; WNDCLASSEX wc; wc.cbSize = sizeof(WNDCLASSEX); wc.style = 0; wc.lpfnWndProc = WndProc; wc.cbClsExtra = 0; wc.cbWndExtra = 0; wc.hInstance = hInstance; wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wc.lpszMenuName = NULL; wc.lpszClassName = g_classWName; wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION); if (!RegisterClassEx(&amp;wc)) &#123; MessageBox(NULL, L&quot;窗口注册失败 | Window Registration Failed!&quot;, L&quot;错误 | Error!&quot;, MB_ICONEXCLAMATION | MB_OK); return 0; &#125; HWND hwnd = CreateWindowExW( 0, g_classWName, L&quot;Win32&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,CW_USEDEFAULT,500,400,//x,y,w,h CW_USEDEFAULT 使用默认 4个都可以 NULL, NULL, hInstance, NULL ); if (hwnd == NULL) &#123; MessageBox(NULL, L&quot;窗口创建失败 | Window Creation Failed!&quot;, L&quot;错误 | Error!&quot;, MB_ICONEXCLAMATION | MB_OK); return 0; &#125; ShowWindow(hwnd, nCmdShow); UpdateWindow(hwnd); MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return (int)msg.wParam;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Win32","slug":"C-C/Win32","permalink":"https://linikc.github.io/categories/C-C/Win32/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"Win32","slug":"Win32","permalink":"https://linikc.github.io/tags/Win32/"}],"author":"Linik"},{"title":"SDL2 2","slug":"SDL2-2","date":"2024-07-06T10:59:39.000Z","updated":"2024-07-28T05:47:02.427Z","comments":true,"path":"2024/07/06/SDL2-2/","link":"","permalink":"https://linikc.github.io/2024/07/06/SDL2-2/","excerpt":"","text":"抠图倘若，你有一幅图","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"SDL2","slug":"C-C/SDL2","permalink":"https://linikc.github.io/categories/C-C/SDL2/"}],"tags":[{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"},{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"}],"author":"Linik"},{"title":"BrainFuck","slug":"BrainFuck","date":"2024-06-28T04:47:28.000Z","updated":"2024-07-28T05:51:58.874Z","comments":true,"path":"2024/06/28/BrainFuck/","link":"","permalink":"https://linikc.github.io/2024/06/28/BrainFuck/","excerpt":"","text":"BrainFuckIntroudectionBrainFuck(BF)正如其名,brain&#x2F;fuck,它是1970年代由Ulrich von Luxburg创造的。按图灵机设计的作为一个极简的编程语言。它只有8个字符： 1234567&gt; //右移指针 p++&lt; //左移指针 p--+ //所在指针的数值加1 (*p)++- //所在指针的数值减1 (*p)--. //输出所在指针的数值(ASCII码), //从输入读取一个字符，存储在所在指针[ //如果所在指针的数值为0，则跳转到对应的] Example举几个简单的例子 1234,.//输入与输出[-]//清零当前指针+++[&gt;++++&lt;-]//3x4+++++[&gt;+++++++++++++&lt;-].//输出A(65) Compile至于编译器,自己看随便搜一搜就出来了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char s[30000]=&#123;0&#125;;char code[100000];int len = 0;int stack[100];int stack_len=0;int main(int argc,char**argv)&#123; char c; int i=0,j,k,x=0; FILE* f; char* p=s+10000; f=fopen(argv[1],&quot;r&quot;); while(fread(&amp;code[len],1,1,f)==1) &#123; len++; &#125; setbuf(stdout,NULL); while(i&lt;len) &#123; switch(code[i]) &#123; case &#x27;+&#x27;: (*p)++; break; case &#x27;-&#x27;: (*p)--; break; case &#x27;&gt;&#x27;: p++; break; case &#x27;&lt;&#x27;: p--; break; case &#x27;.&#x27;: putchar((int)(*p)); //printf(&quot;put:%hdn&quot;,*p); break; case &#x27;,&#x27;: *p=getchar(); break; case &#x27;[&#x27;: if(*p) &#123; stack[stack_len++]=i; &#125; else &#123; for(k=i,j=0;k&lt;len;k++) &#123; code[k]==&#x27;[&#x27;&amp;&amp;j++; code[k]==&#x27;]&#x27;&amp;&amp;j--; if(j==0)break; &#125; if(j==0) i=k; else &#123; fprintf(stderr,&quot;%s:%dn&quot;,__FILE__,__LINE__); return 3; &#125; &#125; break; case &#x27;]&#x27;: i=stack[stack_len-- - 1]-1; break; default: break; &#125; i++; //x++; //printf(&quot;%d : i=%dn&quot;,x,i); &#125; printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/categories/BF/"}],"tags":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/tags/BF/"}],"author":"Linik"},{"title":"Start SDL2","slug":"Start-SDL2","date":"2024-02-09T15:26:42.000Z","updated":"2024-07-06T10:56:30.000Z","comments":true,"path":"2024/02/09/Start-SDL2/","link":"","permalink":"https://linikc.github.io/2024/02/09/Start-SDL2/","excerpt":"","text":"SDL2所谓SDL2就是C++的一个图形库。用来做游戏的 配置包含目录(include)-&gt;SDL中的include文件夹库目录(lib)-&gt;SDL中的lib文件夹链接器-&gt;输入-&gt;附加依赖项 SDL2.lib SDL2main.lib 问题可能编译时遇到LNK 2019的报错或[error LNK2001: 无法解析的外部符号 ___CrtDbgReportW]别问我怎么知道的 这就需要 所在的项目点右键，选择“属性” -&gt; “配置属性” -&gt; “C&#x2F;C++” -&gt; “预处理器” -&gt; “预处理定义” 移除_DENUG或将 _DENUG改为NDENUG或 改成多线程调试DLL(MDd)在链接器命令行中加&#x2F;NODEFAULTLIB:”libcmt.lib” Init1234#include &quot;SDL.h&quot;...int main(int argc,char* args[])... 统一的开头(up) 123456789101112131415SDL_INIT(SDL_INIT_EVERYTHING);//也可以SDL_INIT_VIDEO 差别不大 ==-1指Init 失败SDL_Suface* screen=NULL;SDL_Window* Window=NULL;//SDL2改了SDL_SetVideoModeSDL_CreateWindow(&quot;title&quot;, x,//也可以 SDL_WINDOWPOS_UNDEFINED 默认位置 y, SCREEN_WIDTH,SCREEN_HEIGHT,SDL_WINDOW_SHOWN);screen = SDL_GetWindowSurface(Window);//surface绑定...SDL_UpdateWindowSurface(Window);//updateSDL_Delay(1000);//延迟SDL_DestroyWindow(Window);SDL_Quit();//退出return 0; Load Image原生的SDL2中只能加载BMP格式的图片，只能用SDL2_image官方库加载PNG、JPG、TIFF、WebP、GIF格式的图片 下载https://github.com/libsdl-org/SDL_imagerelease中下载zip看着办 构建进入解压文件中的VisualC打开SDL_image.sln编译 Problem如果报错可能是SDL库没配置 配置include-&gt;include文件夹lib-&gt;编译生成的文件夹(debug&#x2F;release) 链接器-&gt;输入-&gt;附加依赖项 SDL2.lib SDL2main.lib SDL2_image.lib IMG_Load()1234567...#include &lt;SDL_image.h&gt;...IMG_Init(IMG_INIT_PNG);//初始化SDL_Surface* surface = IMG_Load(&quot;path&quot;);//加载图片...IMG_Quit();//退出 Optimize1234567891011121314151617181920212223242526SDL_Surface* loadImage(std::string path)&#123; SDL_Surface* load = NULL; SDL_SUrface* optimized = NULL; //加载图片 load = IMG_Load(path.c_str()); if(load == NULL) &#123; fprintf(stderr, &quot;Unable to load image %s! SDL_image Error: %s\\n&quot;, path.c_str(), IMG_GetError()); return 0; &#125; else &#123; //转换图片 optimized = SDL_ConvertSurface(load, screen-&gt;format, NULL); SDL_FreeSurface(load);//释放load &#125; if(optimized == NULL) &#123; fprintf(stderr, &quot;Unable to optimize image %s! SDL Error: %s\\n&quot;, path.c_str(), SDL_GetError()); return 0; &#125; return optimized;&#125;...SDL_Surface* Image = loadImage(&quot;path&quot;); 上述代码将图片加载到内存中，并转换为屏幕的格式 Show Image1SDL_BlitSurface(Image,NULL,Surface,position); Move Image12345678910...void ApplyImage(SDL_Surface* source,SDL_Surface* destination, int x ,int y)&#123; SDL_Rect offset;//BlitSurface只接受SDL_Rect类型 offset.x = x; offset.y = y; SDL_BlitSurface(source,NULL,destination,&amp;offset);&#125;...ApplyImage(Image,Surface,100,200);//在（100，200）（其实是在100，-200的位置）的位置放图片 Events12345678910SDL_Event event;//state eventwhile(SDL_PollEvent(&amp;event))&#123; switch(event.type) &#123; case SDL_QUIT: quit = true; break; &#125;&#125; SDL_Event 不用”*”否则不兼容 Quit1234SDL_DestroyWindow(Window);//字面意思摧毁窗口SDL_Quit();//SDL exitIMG_Quit();//IMG exitreturn 0;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"SDL2","slug":"C-C/SDL2","permalink":"https://linikc.github.io/categories/C-C/SDL2/"}],"tags":[{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"},{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"}],"author":"Linik"},{"title":"Gluttonous-snake","slug":"Gluttonous-snake","date":"2024-01-30T10:36:08.000Z","updated":"2024-07-28T05:45:36.485Z","comments":true,"path":"2024/01/30/Gluttonous-snake/","link":"","permalink":"https://linikc.github.io/2024/01/30/Gluttonous-snake/","excerpt":"","text":"Gluttonous Snake正所谓贪吃蛇，就是上下左右移动方形的不断变长的蛇在一个方格内吃食物的，每次吃掉一个食物，蛇的长度就增加一格的，蛇的移动速度会加快，当蛇碰到自己的身体或者边界时，游戏结束的一个游戏像废话 CMD Versioninclude12345#include &lt;iostream&gt;//not neccessity#include &lt;list&gt;#include &lt;conio.h&gt;#include &lt;random&gt;//generate random number#include &lt;time.h&gt;//get seed of random number 如上，random用来生成food&amp;snake的随机位置list用来存储snake的各个部分 Initialization1234const int WIDTH = 50;const int HEIGHT =50;//随便填int score=0;//scoreposition head; 为了方便储存xy到list中要定义一个结构 12345struct position&#123; int x,y=0; position(int x,int y):x(x),y(y)&#123;&#125;;&#125; 初始化坐标 123list&lt;position&gt; snake;//snake&#x27;s positionposition food;//food&#x27;s positionposition snakepos;//snake&#x27;s moving direction InitGame()123456789std::srand(time(NULL));//init food positionfood.x=rand()%(WIDTH-2)+1;food.y=rand()%(HEIGHT-2)+1;//init snake positionsnake.push_back(point(WIDTH/2,HEIGHT/2));//Also, can use snake.push_back(position(rand()%(WITDH-2)+1,rand()%(HEIGHT-2)+1));snakepos.x = -1;snakepos.y =0;head=snake.front(); rand()%(n-m+1)+m指的是m与n的随机数 GameLoop()Get input12345678if(_kbhit()) switch(_getch()) &#123; case &#x27;D&#x27; : snakepos.x =1;snakepos.y =0;break; case &#x27;A&#x27; : snakepos.x =-1;snakepos.y =0;break; case &#x27;S&#x27; : snakepos.x =0;snakepos.y =1;break; case &#x27;W&#x27;: snakepos.x =0;snakepos.y =-1;break; &#125; Update12345678910111213141516head.x+=snakepos.x;head.y+=snakepos.y;for(auto it:++snake.begin();it!=snake.end();++it)//cheak whether snake&#x27;s head overlaps with its body if (it-&gt;x==head.x&amp;&amp;it-&gt;y==head.y) return;if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1 &#125; else snake.pop_back();if(head.x &lt;1||head.x&gt;=WIDTH-1||head.y&lt;1||head.y&gt;=HEIGHT-1) return;snake.push_front(head);//update Draw1234567891011121314151617181920212223for(int n=0;n&lt;WIDTH;++n)&#123; for(int m=0;m&lt;HEIGHT;++m) if(n==0||n==WIDTH-1||m==0||m==HEIGHT-1) printf(&quot;#&quot;);//border else &#123; bool print = false; for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); print = true; &#125; if(!print) printf(&quot; &quot;); if(food.x==n&amp;&amp;food.y==m) printf(&quot;F&quot;); &#125; printf(&quot;\\n&quot;);&#125;Sleep(100)//随便system(&quot;cls&quot;)//清屏 如果不用print来判断,而用m+&#x3D;1(如下)将蛇的位置带过会出现向左向右蛇身数目不一致 123456789...for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); ++m; &#125;printf(&quot; &quot;);... result12OOO//向左 O O//向右 ALL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;list&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;#include &lt;random.h&gt;const int WIDTH = 20,HEIGHT = 20;int score=0;struct position&#123; int x,y; position(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;list&lt;position&gt; snake;position food;position snakepos;position head;void InitGame();void GameLoop();int main()&#123; InitGame(); GameLoop(); printf(&quot;Game Over!\\nYour score is %d&quot;,score); Sleep(3000); return 0;&#125;void InitGame()&#123; std::srand(time(NULL)); snake.push_back(position(WIDTH/2,HEIGHT/2)); food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; snakepos.x=1; snakepos.y=0; head=snake.front();&#125;void GameLoop()&#123; while(true) &#123; if(_kbhit()) switch(_getch()) &#123; case &#x27;a&#x27;:snakepos.x=-1;snakepos.y=0;break; case &#x27;d&#x27;:snakepos.x=1;snakepos.y=0;break; case &#x27;w&#x27;:snakepos.x=0;snakepos.y=-1;break; case &#x27;s&#x27;:snakepos.x=0;snakepos.y=1;break; &#125; head.x+=snakepos.x; head.y+=snakepos.y; for(auto it:++snake.begin(),it!=snake.end();++it) if(it-&gt;x==head.x &amp;&amp; it-&gt;y==head.y) return if(head.x==0||head.x==WIDTH-1||head.y==0||head.y==HEIGHT-1) return; if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1; &#125; else snake.pop_back(); snake.push_front(head); for(int n=0;n&lt;HEIGHT;++n) &#123; for(int m=0;m&lt;WIDTH;++m) if(n==0||n==HEIGHT-1||m==0||m==WIDTH-1) printf(&quot;#&quot;); else &#123; bool print=false; for(auto&amp; it:snake) if(it.x==m&amp;&amp;it.y==n) &#123; printf(&quot;O&quot;); print=true; &#125; if(!print) printf(&quot; &quot;); &#125; printf(&quot;\\n&quot;); &#125; system(&quot;cls&quot;); &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Game","slug":"C-C/Game","permalink":"https://linikc.github.io/categories/C-C/Game/"}],"tags":[{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"},{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"}],"author":"Linik"},{"title":"OpenCV Learning","slug":"OpenCV-Learning","date":"2023-10-05T13:45:23.000Z","updated":"2024-07-28T05:45:27.283Z","comments":true,"path":"2023/10/05/OpenCV-Learning/","link":"","permalink":"https://linikc.github.io/2023/10/05/OpenCV-Learning/","excerpt":"","text":"配置: include目录{ include; opencv2; } lib目录{ lib(x64); } Linker{ opencv_world480d.lib; opencv_world480.lib; } Basic123456789101112131415cv::imread&#123; IMREAD_UNCHANGED = -1, //如果设置，则返回的数据带有alpha通道（R,G,B,A 四个通道），否则没有alpha通道 IMREAD_GRAYSCALE = 0, //如果设置，则将图像转换为单通道[灰度图像] IMREAD_COLOR = 1, //如果设置，则将图像转换成3通道BGR彩色图像 IMREAD_ANYDEPTH = 2, //如果设置，则在输入具有相应深度时返回16位/32位图像，否则将其转换为8位 IMREAD_ANYCOLOR = 4, //如果设置，则图像可能以任何颜色格式读取 IMREAD_LOAD_GDAL = 8, //如果设置，使用gdal驱动程序加载图像 IMREAD_REDUCED_GRAYSCALE_2 = 16, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/2 IMREAD_REDUCED_COLOR_2 = 17, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/2 IMREAD_REDUCED_GRAYSCALE_4 = 32, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/4 IMREAD_REDUCED_COLOR_4 = 33, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/4 IMREAD_REDUCED_GRAYSCALE_8 = 64, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/8 IMREAD_REDUCED_COLOR_8 = 65, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/8 IMREAD_IGNORE_ORIENTATION = 128 //如果设置，不会根据EXIF的方向标志旋转图像&#125;; 12345678910111213cv::imshow&#123;8U //如果图像数据类型是8U（8位无符号），则直接显示.16U //如果图像数据类型是16U（16位无符号）或32S（32位有符号整数），则imshow函数内部会自动将每个像素值除以256并显示，即将原图像素值的范围由[0~255*256]映射到[0~255]/*scr1.convertTo(scr2,CV_16U);8U-&gt;16Uscr2.convertTo(scr3,CV_16U,256);16U-&gt;8U**/32F //如果图像数据类型是32F（32位浮点数）或64F（64位浮点数），则imshow函数内部会自动将每个像素值乘以255并显示，即将原图像素值的范围由[0~1]映射到[0~255]（注意：原图像素值必须要归一化）/*scr1.converTo(scr2,CV_32F);normalize(scr2,scr3,0,1,NORM_MINMAX);32F-&gt;8U(lighter)*/&#125;; 调整亮度Formula12g(i,j)=\\alpha f(i,j)+ \\beta\\\\\\beta 增益变量 Code123456789101112131415161718192021int alpha=1.5,beta=100; ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type());int length = OrginalPic.rows;int width = OrginalPic.cols;for (int row = 0; row &lt; length; row++) for(int col=0;col&lt;width;col++) if (OrginalPic.channels() == 1) &#123; float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); &#125; else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125;cv::imshow(&quot;Convert&quot;, ConvertPic); Explain:1ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type()); 创建新的空白的图片(size,type一样) 单通道12float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); 获取像素点灰度(v)将原图的像素点乘以alpha，再加上beta，然后将结果赋值给新图片的像素点cv::saturate_cast 无符号整数&amp;小于255 BGR三通道123456789else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125; BGR三元素分别进行运算再赋值到新像素点","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"OpenCV","slug":"C-C/OpenCV","permalink":"https://linikc.github.io/categories/C-C/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"},{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"}],"author":"Linik"}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Win32","slug":"C-C/Win32","permalink":"https://linikc.github.io/categories/C-C/Win32/"},{"name":"SDL2","slug":"C-C/SDL2","permalink":"https://linikc.github.io/categories/C-C/SDL2/"},{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/categories/BF/"},{"name":"Game","slug":"C-C/Game","permalink":"https://linikc.github.io/categories/C-C/Game/"},{"name":"OpenCV","slug":"C-C/OpenCV","permalink":"https://linikc.github.io/categories/C-C/OpenCV/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"Win32","slug":"Win32","permalink":"https://linikc.github.io/tags/Win32/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"},{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/tags/BF/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}]}