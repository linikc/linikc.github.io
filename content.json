{"meta":{"title":"Linik's Blog","subtitle":"","description":"None","author":"Linik","url":"https://linikc.github.io","root":"/"},"pages":[{"title":"","date":"2023-12-22T14:17:41.668Z","updated":"2023-12-22T14:17:41.668Z","comments":true,"path":"404.html","permalink":"https://linikc.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-12-22T14:12:09.437Z","updated":"2023-12-22T14:12:09.437Z","comments":true,"path":"faq/index.html","permalink":"https://linikc.github.io/faq/index.html","excerpt":"","text":"FAQ"},{"title":"所有标签","date":"2023-12-17T07:26:35.101Z","updated":"2023-12-17T07:26:35.101Z","comments":true,"path":"tags/index.html","permalink":"https://linikc.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-12-17T07:24:22.223Z","updated":"2023-12-17T07:24:22.223Z","comments":true,"path":"about/index.html","permalink":"https://linikc.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-12-17T07:25:34.116Z","updated":"2023-12-17T07:25:34.116Z","comments":true,"path":"categories/index.html","permalink":"https://linikc.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-12-17T07:25:55.421Z","updated":"2023-12-17T07:25:55.421Z","comments":true,"path":"mylist/index.html","permalink":"https://linikc.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenCV Learning","slug":"OpenCV-Learning","date":"2023-10-05T13:45:23.000Z","updated":"2023-12-17T07:30:24.918Z","comments":true,"path":"2023/10/05/OpenCV-Learning/","link":"","permalink":"https://linikc.github.io/2023/10/05/OpenCV-Learning/","excerpt":"","text":"配置: include目录{ include; opencv2; } lib目录{ lib(x64); } Linker{ opencv_world480d.lib; opencv_world480.lib; } Basic123456789101112131415cv::imread&#123; IMREAD_UNCHANGED = -1, //如果设置，则返回的数据带有alpha通道（R,G,B,A 四个通道），否则没有alpha通道 IMREAD_GRAYSCALE = 0, //如果设置，则将图像转换为单通道[灰度图像] IMREAD_COLOR = 1, //如果设置，则将图像转换成3通道BGR彩色图像 IMREAD_ANYDEPTH = 2, //如果设置，则在输入具有相应深度时返回16位/32位图像，否则将其转换为8位 IMREAD_ANYCOLOR = 4, //如果设置，则图像可能以任何颜色格式读取 IMREAD_LOAD_GDAL = 8, //如果设置，使用gdal驱动程序加载图像 IMREAD_REDUCED_GRAYSCALE_2 = 16, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/2 IMREAD_REDUCED_COLOR_2 = 17, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/2 IMREAD_REDUCED_GRAYSCALE_4 = 32, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/4 IMREAD_REDUCED_COLOR_4 = 33, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/4 IMREAD_REDUCED_GRAYSCALE_8 = 64, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/8 IMREAD_REDUCED_COLOR_8 = 65, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/8 IMREAD_IGNORE_ORIENTATION = 128 //如果设置，不会根据EXIF的方向标志旋转图像&#125;; 12345678910111213cv::imshow&#123;8U //如果图像数据类型是8U（8位无符号），则直接显示.16U //如果图像数据类型是16U（16位无符号）或32S（32位有符号整数），则imshow函数内部会自动将每个像素值除以256并显示，即将原图像素值的范围由[0~255*256]映射到[0~255]/*scr1.convertTo(scr2,CV_16U);8U-&gt;16Uscr2.convertTo(scr3,CV_16U,256);16U-&gt;8U**/32F //如果图像数据类型是32F（32位浮点数）或64F（64位浮点数），则imshow函数内部会自动将每个像素值乘以255并显示，即将原图像素值的范围由[0~1]映射到[0~255]（注意：原图像素值必须要归一化）/*scr1.converTo(scr2,CV_32F);normalize(scr2,scr3,0,1,NORM_MINMAX);32F-&gt;8U(lighter)*/&#125;; 调整亮度Formula12g(i,j)=\\alpha f(i,j)+ \\beta\\\\\\beta 增益变量 Code123456789101112131415161718192021int alpha=1.5,beta=100; ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type());int length = OrginalPic.rows;int width = OrginalPic.cols;for (int row = 0; row &lt; length; row++) for(int col=0;col&lt;width;col++) if (OrginalPic.channels() == 1) &#123; float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); &#125; else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125;cv::imshow(&quot;Convert&quot;, ConvertPic); Explain:1ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type()); 创建新的空白的图片(size,type一样) 单通道12float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); 获取像素点灰度(v)将原图的像素点乘以alpha，再加上beta，然后将结果赋值给新图片的像素点cv::saturate_cast 无符号整数&amp;小于255 BGR三通道123456789else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125; BGR三元素分别进行运算再赋值到新像素点","categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}],"author":"Linik"}],"categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}]}