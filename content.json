{"meta":{"title":"Linik's Blog","subtitle":"","description":"A personal blog","author":"Linik","url":"https://linikc.github.io","root":"/"},"pages":[{"title":"","date":"2023-12-31T14:04:33.274Z","updated":"2023-12-31T14:04:33.274Z","comments":true,"path":"about/index.html","permalink":"https://linikc.github.io/about/index.html","excerpt":"","text":"About myselfJust a student from China.I have nothing special. I am just an ordinary person."},{"title":"","date":"2023-12-22T14:17:41.668Z","updated":"2023-12-22T14:17:41.668Z","comments":true,"path":"404.html","permalink":"https://linikc.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-12-31T13:38:33.738Z","updated":"2023-12-31T13:38:33.738Z","comments":true,"path":"faq/index.html","permalink":"https://linikc.github.io/faq/index.html","excerpt":"","text":"FAQUntil now, we don’t have any problem"},{"title":"","date":"2023-12-17T07:25:55.421Z","updated":"2023-12-17T07:25:55.421Z","comments":true,"path":"mylist/index.html","permalink":"https://linikc.github.io/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2024-01-20T08:43:46.670Z","updated":"2024-01-20T08:43:46.670Z","comments":true,"path":"chat/index.html","permalink":"https://linikc.github.io/chat/index.html","excerpt":"","text":"Chat"},{"title":"所有分类","date":"2023-12-17T07:25:34.116Z","updated":"2023-12-17T07:25:34.116Z","comments":true,"path":"categories/index.html","permalink":"https://linikc.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-12-17T07:26:35.101Z","updated":"2023-12-17T07:26:35.101Z","comments":true,"path":"tags/index.html","permalink":"https://linikc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Gluttonous-snake","slug":"Gluttonous-snake","date":"2024-01-30T10:36:08.000Z","updated":"2024-02-05T09:51:35.024Z","comments":true,"path":"2024/01/30/Gluttonous-snake/","link":"","permalink":"https://linikc.github.io/2024/01/30/Gluttonous-snake/","excerpt":"","text":"Gluttonous Snake正所谓贪吃蛇，就是上下左右移动方形的不断变长的蛇在一个方格内吃食物的，每次吃掉一个食物，蛇的长度就增加一格的，蛇的移动速度会加快，当蛇碰到自己的身体或者边界时，游戏结束的一个游戏像废话 CMD Versioninclude12345#include &lt;iostream&gt;//not neccessity#include &lt;list&gt;#include &lt;conio.h&gt;#include &lt;random&gt;//generate random number#include &lt;time.h&gt;//get seed of random number 如上，random用来生成food&amp;snake的随机位置list用来存储snake的各个部分 Initialization1234const int WIDTH = 50;const int HEIGHT =50;//随便填int score=0;//scoreposition head; 为了方便储存xy到list中要定义一个结构 12345struct position&#123; int x,y=0; position(int x,int y):x(x),y(y)&#123;&#125;;&#125; 初始化坐标 123list&lt;position&gt; snake;//snake&#x27;s positionposition food;//food&#x27;s positionposition snakepos;//snake&#x27;s moving direction InitGame()123456789std::srand(time(NULL));//init food positionfood.x=rand()%(WIDTH-2)+1;food.y=rand()%(HEIGHT-2)+1;//init snake positionsnake.push_back(point(WIDTH/2,HEIGHT/2));//Also, can use snake.push_back(position(rand()%(WITDH-2)+1,rand()%(HEIGHT-2)+1));snakepos.x = -1;snakepos.y =0;head=snake.front(); rand()%(n-m+1)+m指的是m与n的随机数 GameLoop()Get input12345678if(_kbhit()) switch(_getch()) &#123; case &#x27;D&#x27; : snakepos.x =1;snakepos.y =0;break; case &#x27;A&#x27; : snakepos.x =-1;snakepos.y =0;break; case &#x27;S&#x27; : snakepos.x =0;snakepos.y =1;break; case &#x27;W&#x27;: snakepos.x =0;snakepos.y =-1;break; &#125; Update12345678910111213141516head.x+=snakepos.x;head.y+=snakepos.y;for(auto it:++snake.begin();it!=snake.end();++it)//cheak whether snake&#x27;s head overlaps with its body if (it-&gt;x==head.x&amp;&amp;it-&gt;y==head.y) return;if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1 &#125; else snake.pop_back();if(head.x &lt;1||head.x&gt;=WIDTH-1||head.y&lt;1||head.y&gt;=HEIGHT-1) return;snake.push_front(head);//update Draw1234567891011121314151617181920212223for(int n=0;n&lt;WIDTH;++n)&#123; for(int m=0;m&lt;HEIGHT;++m) if(n==0||n==WIDTH-1||m==0||m==HEIGHT-1) printf(&quot;#&quot;);//border else &#123; bool print = false; for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); print = true; &#125; if(!print) printf(&quot; &quot;); if(food.x==n&amp;&amp;food.y==m) printf(&quot;F&quot;); &#125; printf(&quot;\\n&quot;);&#125;Sleep(100)//随便system(&quot;cls&quot;)//清屏 如果不用print来判断,而用m+&#x3D;1(如下)将蛇的位置带过会出现向左向右蛇身数目不一致 123456789...for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); ++m; &#125;printf(&quot; &quot;);... result12OOO//向左 O O//向右 ALL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;list&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;#include &lt;random.h&gt;const int WIDTH = 20,HEIGHT = 20;int score=0;struct position&#123; int x,y; position(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;list&lt;position&gt; snake;position food;position snakepos;position head;void InitGame();void GameLoop();int main()&#123; InitGame(); GameLoop(); printf(&quot;Game Over!\\nYour score is %d&quot;,score); Sleep(3000); return 0;&#125;void InitGame()&#123; std::srand(time(NULL)); snake.push_back(position(WIDTH/2,HEIGHT/2)); food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; snakepos.x=1; snakepos.y=0; head=snake.front();&#125;void GameLoop()&#123; while(true) &#123; if(_kbhit()) switch(_getch()) &#123; case &#x27;a&#x27;:snakepos.x=-1;snakepos.y=0;break; case &#x27;d&#x27;:snakepos.x=1;snakepos.y=0;break; case &#x27;w&#x27;:snakepos.x=0;snakepos.y=-1;break; case &#x27;s&#x27;:snakepos.x=0;snakepos.y=1;break; &#125; head.x+=snakepos.x; head.y+=snakepos.y; for(auto it:++snake.begin(),it!=snake.end();++it) if(it-&gt;x==head.x &amp;&amp; it-&gt;y==head.y) return if(head.x==0||head.x==WIDTH-1||head.y==0||head.y==HEIGHT-1) return; if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1; &#125; else snake.pop_back(); snake.push_front(head); for(int n=0;n&lt;HEIGHT;++n) &#123; for(int m=0;m&lt;WIDTH;++m) if(n==0||n==HEIGHT-1||m==0||m==WIDTH-1) printf(&quot;#&quot;); else &#123; bool print=false; for(auto&amp; it:snake) if(it.x==m&amp;&amp;it.y==n) &#123; printf(&quot;O&quot;); print=true; &#125; if(!print) printf(&quot; &quot;); &#125; printf(&quot;\\n&quot;); &#125; system(&quot;cls&quot;); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"},{"name":"Game","slug":"C/Game","permalink":"https://linikc.github.io/categories/C/Game/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"}],"author":"Linik"},{"title":"OpenCV Learning","slug":"OpenCV-Learning","date":"2023-10-05T13:45:23.000Z","updated":"2023-12-24T07:08:29.382Z","comments":true,"path":"2023/10/05/OpenCV-Learning/","link":"","permalink":"https://linikc.github.io/2023/10/05/OpenCV-Learning/","excerpt":"","text":"配置: include目录{ include; opencv2; } lib目录{ lib(x64); } Linker{ opencv_world480d.lib; opencv_world480.lib; } Basic123456789101112131415cv::imread&#123; IMREAD_UNCHANGED = -1, //如果设置，则返回的数据带有alpha通道（R,G,B,A 四个通道），否则没有alpha通道 IMREAD_GRAYSCALE = 0, //如果设置，则将图像转换为单通道[灰度图像] IMREAD_COLOR = 1, //如果设置，则将图像转换成3通道BGR彩色图像 IMREAD_ANYDEPTH = 2, //如果设置，则在输入具有相应深度时返回16位/32位图像，否则将其转换为8位 IMREAD_ANYCOLOR = 4, //如果设置，则图像可能以任何颜色格式读取 IMREAD_LOAD_GDAL = 8, //如果设置，使用gdal驱动程序加载图像 IMREAD_REDUCED_GRAYSCALE_2 = 16, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/2 IMREAD_REDUCED_COLOR_2 = 17, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/2 IMREAD_REDUCED_GRAYSCALE_4 = 32, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/4 IMREAD_REDUCED_COLOR_4 = 33, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/4 IMREAD_REDUCED_GRAYSCALE_8 = 64, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/8 IMREAD_REDUCED_COLOR_8 = 65, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/8 IMREAD_IGNORE_ORIENTATION = 128 //如果设置，不会根据EXIF的方向标志旋转图像&#125;; 12345678910111213cv::imshow&#123;8U //如果图像数据类型是8U（8位无符号），则直接显示.16U //如果图像数据类型是16U（16位无符号）或32S（32位有符号整数），则imshow函数内部会自动将每个像素值除以256并显示，即将原图像素值的范围由[0~255*256]映射到[0~255]/*scr1.convertTo(scr2,CV_16U);8U-&gt;16Uscr2.convertTo(scr3,CV_16U,256);16U-&gt;8U**/32F //如果图像数据类型是32F（32位浮点数）或64F（64位浮点数），则imshow函数内部会自动将每个像素值乘以255并显示，即将原图像素值的范围由[0~1]映射到[0~255]（注意：原图像素值必须要归一化）/*scr1.converTo(scr2,CV_32F);normalize(scr2,scr3,0,1,NORM_MINMAX);32F-&gt;8U(lighter)*/&#125;; 调整亮度Formula12g(i,j)=\\alpha f(i,j)+ \\beta\\\\\\beta 增益变量 Code123456789101112131415161718192021int alpha=1.5,beta=100; ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type());int length = OrginalPic.rows;int width = OrginalPic.cols;for (int row = 0; row &lt; length; row++) for(int col=0;col&lt;width;col++) if (OrginalPic.channels() == 1) &#123; float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); &#125; else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125;cv::imshow(&quot;Convert&quot;, ConvertPic); Explain:1ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type()); 创建新的空白的图片(size,type一样) 单通道12float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); 获取像素点灰度(v)将原图的像素点乘以alpha，再加上beta，然后将结果赋值给新图片的像素点cv::saturate_cast 无符号整数&amp;小于255 BGR三通道123456789else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125; BGR三元素分别进行运算再赋值到新像素点","categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}],"author":"Linik"}],"categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"},{"name":"Game","slug":"C/Game","permalink":"https://linikc.github.io/categories/C/Game/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}]}