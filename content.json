{"meta":{"title":"Linik's Blog","subtitle":"","description":"A personal blog","author":"Linik","url":"https://linikc.github.io","root":"/"},"pages":[{"title":"","date":"2024-02-16T09:44:23.771Z","updated":"2024-02-16T09:44:23.771Z","comments":true,"path":"about/index.html","permalink":"https://linikc.github.io/about/index.html","excerpt":"","text":"About myselfJust a student from China.I have nothing special. I am just an ordinary person."},{"title":"","date":"2023-12-22T14:17:41.668Z","updated":"2023-12-22T14:17:41.668Z","comments":true,"path":"404.html","permalink":"https://linikc.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-12-31T13:38:33.738Z","updated":"2023-12-31T13:38:33.738Z","comments":true,"path":"faq/index.html","permalink":"https://linikc.github.io/faq/index.html","excerpt":"","text":"FAQUntil now, we don’t have any problem"},{"title":"","date":"2023-12-17T07:25:55.421Z","updated":"2023-12-17T07:25:55.421Z","comments":true,"path":"mylist/index.html","permalink":"https://linikc.github.io/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2024-01-20T08:43:46.670Z","updated":"2024-01-20T08:43:46.670Z","comments":true,"path":"chat/index.html","permalink":"https://linikc.github.io/chat/index.html","excerpt":"","text":"Chat"},{"title":"所有分类","date":"2023-12-17T07:25:34.116Z","updated":"2023-12-17T07:25:34.116Z","comments":true,"path":"categories/index.html","permalink":"https://linikc.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-12-17T07:26:35.101Z","updated":"2023-12-17T07:26:35.101Z","comments":true,"path":"tags/index.html","permalink":"https://linikc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BrainFuck","slug":"BrainFuck","date":"2024-06-28T04:47:28.000Z","updated":"2024-06-28T05:13:03.143Z","comments":true,"path":"2024/06/28/BrainFuck/","link":"","permalink":"https://linikc.github.io/2024/06/28/BrainFuck/","excerpt":"","text":"IntroudectionBrainFuck(BF)正如其名,brain&#x2F;fuck,它是1970年代由Ulrich von Luxburg创造的。按图灵机设计的作为一个极简的编程语言。它只有8个字符： 1234567&gt; //右移指针 p++&lt; //左移指针 p--+ //所在指针的数值加1 (*p)++- //所在指针的数值减1 (*p)--. //输出所在指针的数值(ASCII码), //从输入读取一个字符，存储在所在指针[ //如果所在指针的数值为0，则跳转到对应的] Example举几个简单的例子 1234,.//输入与输出[-]//清零当前指针+++[&gt;++++&lt;-]//3x4+++++[&gt;+++++++++++++&lt;-].//输出A(65) Compile至于编译器,自己看随便搜一搜就出来了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char s[30000]=&#123;0&#125;;char code[100000];int len = 0;int stack[100];int stack_len=0;int main(int argc,char**argv)&#123; char c; int i=0,j,k,x=0; FILE* f; char* p=s+10000; f=fopen(argv[1],&quot;r&quot;); while(fread(&amp;code[len],1,1,f)==1) &#123; len++; &#125; setbuf(stdout,NULL); while(i&lt;len) &#123; switch(code[i]) &#123; case &#x27;+&#x27;: (*p)++; break; case &#x27;-&#x27;: (*p)--; break; case &#x27;&gt;&#x27;: p++; break; case &#x27;&lt;&#x27;: p--; break; case &#x27;.&#x27;: putchar((int)(*p)); //printf(&quot;put:%hdn&quot;,*p); break; case &#x27;,&#x27;: *p=getchar(); break; case &#x27;[&#x27;: if(*p) &#123; stack[stack_len++]=i; &#125; else &#123; for(k=i,j=0;k&lt;len;k++) &#123; code[k]==&#x27;[&#x27;&amp;&amp;j++; code[k]==&#x27;]&#x27;&amp;&amp;j--; if(j==0)break; &#125; if(j==0) i=k; else &#123; fprintf(stderr,&quot;%s:%dn&quot;,__FILE__,__LINE__); return 3; &#125; &#125; break; case &#x27;]&#x27;: i=stack[stack_len-- - 1]-1; break; default: break; &#125; i++; //x++; //printf(&quot;%d : i=%dn&quot;,x,i); &#125; printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/categories/BF/"}],"tags":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/tags/BF/"}],"author":"Linik"},{"title":"Start SDL2","slug":"Start-SDL2","date":"2024-02-09T15:26:42.000Z","updated":"2024-05-05T00:30:35.347Z","comments":true,"path":"2024/02/09/Start-SDL2/","link":"","permalink":"https://linikc.github.io/2024/02/09/Start-SDL2/","excerpt":"","text":"SDL2所谓SDL2就是C++的一个图形库。用来做游戏的 配置包含目录(include)-&gt;SDL中的include文件夹库目录(lib)-&gt;SDL中的lib文件夹链接器-&gt;输入-&gt;附加依赖项 SDL2.lib SDL2main.lib 问题可能编译时遇到LNK 2019的报错或[error LNK2001: 无法解析的外部符号 ___CrtDbgReportW]别问我怎么知道的 这就需要 所在的项目点右键，选择“属性” -&gt; “配置属性” -&gt; “C&#x2F;C++” -&gt; “预处理器” -&gt; “预处理定义” 移除_DENUG或将 _DENUG改为NDENUG或 改成多线程调试DLL(MDd)在链接器命令行中加&#x2F;NODEFAULTLIB:”libcmt.lib” Init1234#include &quot;SDL.h&quot;...int main(int argc,char* args[])... 统一的开头(up) 123456789101112131415SDL_INIT(SDL_INIT_EVERYTHING);//也可以SDL_INIT_VIDEO 差别不大 ==-1指Init 失败SDL_Suface* screen=NULL;SDL_Window* Window=NULL;//SDL2改了SDL_SetVideoModeSDL_CreateWindow(&quot;title&quot;, x,//也可以 SDL_WINDOWPOS_UNDEFINED 默认位置 y, SCREEN_WIDTH,SCREEN_HEIGHT,SDL_WINDOW_SHOWN);screen = SDL_GetWindowSurface(Window);//surface绑定...SDL_UpdateWindowSurface(Window);//updateSDL_Delay(1000);//延迟SDL_DestroyWindow(Window);SDL_Quit();//退出return 0; Load Image原生的SDL2中只能加载BMP格式的图片，只能用SDL2_image官方库加载PNG、JPG、TIFF、WebP、GIF格式的图片 下载https://github.com/libsdl-org/SDL_imagerelease中下载zip看着办 构建进入解压文件中的VisualC打开SDL_image.sln编译 Problem如果报错可能是SDL库没配置 配置include-&gt;include文件夹lib-&gt;编译生成的文件夹(debug&#x2F;release) 链接器-&gt;输入-&gt;附加依赖项 SDL2.lib SDL2main.lib SDL2_image.lib IMG_Load()1234567...#include &lt;SDL_image.h&gt;...IMG_Init(IMG_INIT_PNG);//初始化SDL_Surface* surface = IMG_Load(&quot;path&quot;);//加载图片...IMG_Quit();//退出 Optimize1234567891011121314151617181920212223242526SDL_Surface* loadImage(std::string path)&#123; SDL_Surface* load = NULL; SDL_SUrface* optimized = NULL; //加载图片 load = IMG_Load(path.c_str()); if(load == NULL) &#123; fprintf(stderr, &quot;Unable to load image %s! SDL_image Error: %s\\n&quot;, path.c_str(), IMG_GetError()); return 0; &#125; else &#123; //转换图片 optimized = SDL_ConvertSurface(load, screen-&gt;format, NULL); SDL_FreeSurface(load);//释放load &#125; if(optimized == NULL) &#123; fprintf(stderr, &quot;Unable to optimize image %s! SDL Error: %s\\n&quot;, path.c_str(), SDL_GetError()); return 0; &#125; return optimized;&#125;...SDL_Surface* Image = loadImage(&quot;path&quot;); 上述代码将图片加载到内存中，并转换为屏幕的格式 Show Image1SDL_BlitSurface(Image,NULL,Surface,position); Move Image12345678910...void ApplyImage(SDL_Surface* source,SDL_Surface* destination, int x ,int y)&#123; SDL_Rect offset;//BlitSurface只接受SDL_Rect类型 offset.x = x; offset.y = y; SDL_BlitSurface(source,NULL,destination,&amp;offset);&#125;...ApplyImage(Image,SUrface,100,200);//在（100，200）（其实是在100，-200的位置）的位置放图片 Events","categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"},{"name":"SDL2","slug":"C/SDL2","permalink":"https://linikc.github.io/categories/C/SDL2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"}],"author":"Linik"},{"title":"Gluttonous-snake","slug":"Gluttonous-snake","date":"2024-01-30T10:36:08.000Z","updated":"2024-02-05T09:51:35.024Z","comments":true,"path":"2024/01/30/Gluttonous-snake/","link":"","permalink":"https://linikc.github.io/2024/01/30/Gluttonous-snake/","excerpt":"","text":"Gluttonous Snake正所谓贪吃蛇，就是上下左右移动方形的不断变长的蛇在一个方格内吃食物的，每次吃掉一个食物，蛇的长度就增加一格的，蛇的移动速度会加快，当蛇碰到自己的身体或者边界时，游戏结束的一个游戏像废话 CMD Versioninclude12345#include &lt;iostream&gt;//not neccessity#include &lt;list&gt;#include &lt;conio.h&gt;#include &lt;random&gt;//generate random number#include &lt;time.h&gt;//get seed of random number 如上，random用来生成food&amp;snake的随机位置list用来存储snake的各个部分 Initialization1234const int WIDTH = 50;const int HEIGHT =50;//随便填int score=0;//scoreposition head; 为了方便储存xy到list中要定义一个结构 12345struct position&#123; int x,y=0; position(int x,int y):x(x),y(y)&#123;&#125;;&#125; 初始化坐标 123list&lt;position&gt; snake;//snake&#x27;s positionposition food;//food&#x27;s positionposition snakepos;//snake&#x27;s moving direction InitGame()123456789std::srand(time(NULL));//init food positionfood.x=rand()%(WIDTH-2)+1;food.y=rand()%(HEIGHT-2)+1;//init snake positionsnake.push_back(point(WIDTH/2,HEIGHT/2));//Also, can use snake.push_back(position(rand()%(WITDH-2)+1,rand()%(HEIGHT-2)+1));snakepos.x = -1;snakepos.y =0;head=snake.front(); rand()%(n-m+1)+m指的是m与n的随机数 GameLoop()Get input12345678if(_kbhit()) switch(_getch()) &#123; case &#x27;D&#x27; : snakepos.x =1;snakepos.y =0;break; case &#x27;A&#x27; : snakepos.x =-1;snakepos.y =0;break; case &#x27;S&#x27; : snakepos.x =0;snakepos.y =1;break; case &#x27;W&#x27;: snakepos.x =0;snakepos.y =-1;break; &#125; Update12345678910111213141516head.x+=snakepos.x;head.y+=snakepos.y;for(auto it:++snake.begin();it!=snake.end();++it)//cheak whether snake&#x27;s head overlaps with its body if (it-&gt;x==head.x&amp;&amp;it-&gt;y==head.y) return;if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1 &#125; else snake.pop_back();if(head.x &lt;1||head.x&gt;=WIDTH-1||head.y&lt;1||head.y&gt;=HEIGHT-1) return;snake.push_front(head);//update Draw1234567891011121314151617181920212223for(int n=0;n&lt;WIDTH;++n)&#123; for(int m=0;m&lt;HEIGHT;++m) if(n==0||n==WIDTH-1||m==0||m==HEIGHT-1) printf(&quot;#&quot;);//border else &#123; bool print = false; for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); print = true; &#125; if(!print) printf(&quot; &quot;); if(food.x==n&amp;&amp;food.y==m) printf(&quot;F&quot;); &#125; printf(&quot;\\n&quot;);&#125;Sleep(100)//随便system(&quot;cls&quot;)//清屏 如果不用print来判断,而用m+&#x3D;1(如下)将蛇的位置带过会出现向左向右蛇身数目不一致 123456789...for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); ++m; &#125;printf(&quot; &quot;);... result12OOO//向左 O O//向右 ALL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;list&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;#include &lt;random.h&gt;const int WIDTH = 20,HEIGHT = 20;int score=0;struct position&#123; int x,y; position(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;list&lt;position&gt; snake;position food;position snakepos;position head;void InitGame();void GameLoop();int main()&#123; InitGame(); GameLoop(); printf(&quot;Game Over!\\nYour score is %d&quot;,score); Sleep(3000); return 0;&#125;void InitGame()&#123; std::srand(time(NULL)); snake.push_back(position(WIDTH/2,HEIGHT/2)); food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; snakepos.x=1; snakepos.y=0; head=snake.front();&#125;void GameLoop()&#123; while(true) &#123; if(_kbhit()) switch(_getch()) &#123; case &#x27;a&#x27;:snakepos.x=-1;snakepos.y=0;break; case &#x27;d&#x27;:snakepos.x=1;snakepos.y=0;break; case &#x27;w&#x27;:snakepos.x=0;snakepos.y=-1;break; case &#x27;s&#x27;:snakepos.x=0;snakepos.y=1;break; &#125; head.x+=snakepos.x; head.y+=snakepos.y; for(auto it:++snake.begin(),it!=snake.end();++it) if(it-&gt;x==head.x &amp;&amp; it-&gt;y==head.y) return if(head.x==0||head.x==WIDTH-1||head.y==0||head.y==HEIGHT-1) return; if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1; &#125; else snake.pop_back(); snake.push_front(head); for(int n=0;n&lt;HEIGHT;++n) &#123; for(int m=0;m&lt;WIDTH;++m) if(n==0||n==HEIGHT-1||m==0||m==WIDTH-1) printf(&quot;#&quot;); else &#123; bool print=false; for(auto&amp; it:snake) if(it.x==m&amp;&amp;it.y==n) &#123; printf(&quot;O&quot;); print=true; &#125; if(!print) printf(&quot; &quot;); &#125; printf(&quot;\\n&quot;); &#125; system(&quot;cls&quot;); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"},{"name":"Game","slug":"C/Game","permalink":"https://linikc.github.io/categories/C/Game/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"}],"author":"Linik"},{"title":"OpenCV Learning","slug":"OpenCV-Learning","date":"2023-10-05T13:45:23.000Z","updated":"2023-12-24T07:08:29.382Z","comments":true,"path":"2023/10/05/OpenCV-Learning/","link":"","permalink":"https://linikc.github.io/2023/10/05/OpenCV-Learning/","excerpt":"","text":"配置: include目录{ include; opencv2; } lib目录{ lib(x64); } Linker{ opencv_world480d.lib; opencv_world480.lib; } Basic123456789101112131415cv::imread&#123; IMREAD_UNCHANGED = -1, //如果设置，则返回的数据带有alpha通道（R,G,B,A 四个通道），否则没有alpha通道 IMREAD_GRAYSCALE = 0, //如果设置，则将图像转换为单通道[灰度图像] IMREAD_COLOR = 1, //如果设置，则将图像转换成3通道BGR彩色图像 IMREAD_ANYDEPTH = 2, //如果设置，则在输入具有相应深度时返回16位/32位图像，否则将其转换为8位 IMREAD_ANYCOLOR = 4, //如果设置，则图像可能以任何颜色格式读取 IMREAD_LOAD_GDAL = 8, //如果设置，使用gdal驱动程序加载图像 IMREAD_REDUCED_GRAYSCALE_2 = 16, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/2 IMREAD_REDUCED_COLOR_2 = 17, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/2 IMREAD_REDUCED_GRAYSCALE_4 = 32, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/4 IMREAD_REDUCED_COLOR_4 = 33, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/4 IMREAD_REDUCED_GRAYSCALE_8 = 64, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/8 IMREAD_REDUCED_COLOR_8 = 65, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/8 IMREAD_IGNORE_ORIENTATION = 128 //如果设置，不会根据EXIF的方向标志旋转图像&#125;; 12345678910111213cv::imshow&#123;8U //如果图像数据类型是8U（8位无符号），则直接显示.16U //如果图像数据类型是16U（16位无符号）或32S（32位有符号整数），则imshow函数内部会自动将每个像素值除以256并显示，即将原图像素值的范围由[0~255*256]映射到[0~255]/*scr1.convertTo(scr2,CV_16U);8U-&gt;16Uscr2.convertTo(scr3,CV_16U,256);16U-&gt;8U**/32F //如果图像数据类型是32F（32位浮点数）或64F（64位浮点数），则imshow函数内部会自动将每个像素值乘以255并显示，即将原图像素值的范围由[0~1]映射到[0~255]（注意：原图像素值必须要归一化）/*scr1.converTo(scr2,CV_32F);normalize(scr2,scr3,0,1,NORM_MINMAX);32F-&gt;8U(lighter)*/&#125;; 调整亮度Formula12g(i,j)=\\alpha f(i,j)+ \\beta\\\\\\beta 增益变量 Code123456789101112131415161718192021int alpha=1.5,beta=100; ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type());int length = OrginalPic.rows;int width = OrginalPic.cols;for (int row = 0; row &lt; length; row++) for(int col=0;col&lt;width;col++) if (OrginalPic.channels() == 1) &#123; float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); &#125; else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125;cv::imshow(&quot;Convert&quot;, ConvertPic); Explain:1ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type()); 创建新的空白的图片(size,type一样) 单通道12float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); 获取像素点灰度(v)将原图的像素点乘以alpha，再加上beta，然后将结果赋值给新图片的像素点cv::saturate_cast 无符号整数&amp;小于255 BGR三通道123456789else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125; BGR三元素分别进行运算再赋值到新像素点","categories":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}],"author":"Linik"}],"categories":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/categories/BF/"},{"name":"C++","slug":"C","permalink":"https://linikc.github.io/categories/C/"},{"name":"SDL2","slug":"C/SDL2","permalink":"https://linikc.github.io/categories/C/SDL2/"},{"name":"Game","slug":"C/Game","permalink":"https://linikc.github.io/categories/C/Game/"}],"tags":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/tags/BF/"},{"name":"C++","slug":"C","permalink":"https://linikc.github.io/tags/C/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}]}