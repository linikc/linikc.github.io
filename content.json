{"meta":{"title":"Linik's Blog","subtitle":"","description":"A personal blog","author":"Linik","url":"https://linikc.github.io","root":"/"},"pages":[{"title":"","date":"2024-02-16T09:44:23.771Z","updated":"2024-02-16T09:44:23.771Z","comments":true,"path":"about/index.html","permalink":"https://linikc.github.io/about/index.html","excerpt":"","text":"About myselfJust a student from China.I have nothing special. I am just an ordinary person."},{"title":"","date":"2024-09-01T07:57:49.672Z","updated":"2024-09-01T07:57:49.672Z","comments":true,"path":"404.html","permalink":"https://linikc.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-09-06T10:25:04.499Z","updated":"2024-09-06T10:25:04.499Z","comments":true,"path":"beaudar.json","permalink":"https://linikc.github.io/beaudar.json","excerpt":"","text":"{\"origins\":[\"https://linikc.github.io\"]}"},{"title":"所有分类","date":"2023-12-17T07:25:34.116Z","updated":"2023-12-17T07:25:34.116Z","comments":true,"path":"categories/index.html","permalink":"https://linikc.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-06T10:48:58.117Z","updated":"2024-07-06T10:48:58.117Z","comments":true,"path":"faq/index.html","permalink":"https://linikc.github.io/faq/index.html","excerpt":"","text":"FAQUntil now, we don’t have any problem Some Problems in our daily life1.百度同步空间图标删除regedit：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\找到有关同步空间的目录删掉，只有一项,为REG_SZ类型，可用查找搜索“同步空间”or 需要在边栏同步那先开启同步然后关闭同步就会消失"},{"title":"","date":"2024-01-20T08:43:46.670Z","updated":"2024-01-20T08:43:46.670Z","comments":true,"path":"chat/index.html","permalink":"https://linikc.github.io/chat/index.html","excerpt":"","text":"Chat"},{"title":"所有标签","date":"2023-12-17T07:26:35.101Z","updated":"2023-12-17T07:26:35.101Z","comments":true,"path":"tags/index.html","permalink":"https://linikc.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-12-17T07:25:55.421Z","updated":"2023-12-17T07:25:55.421Z","comments":true,"path":"mylist/index.html","permalink":"https://linikc.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"Clock","slug":"Clock","date":"2025-09-14T07:04:48.000Z","updated":"2025-10-19T05:04:07.350Z","comments":true,"path":"2025/09/14/Clock/","link":"","permalink":"https://linikc.github.io/2025/09/14/Clock/","excerpt":"","text":"引言心血来潮想做一个简单的时钟来提升自己得编程水平，于是就有了这个项目。虽然很没用 原理 绘图方面的话，从简单入手，于是就用EasyX这个图形库来简便开发。毕竟我也没能力手搓 文件结构的话，main是必须的，然后把各个功能：如绘图，交互，时钟逻辑等放在各个文件里，然后main通过Timer头文件来建立与其他文件的练习,这是结构：1234567891011-Clock |Cpp |-main.cpp |-Interaction.cpp \\\\for coping with the keyboard input|-Logic.cpp \\\\main logic for the clock|-Display.cpp \\\\for displaying the clock|Header |-Display.h|-Logic.h|-Interaction.h|-Timer.h 至于时钟逻辑方面，可以把功能拆分，基本功能为计数器，就是将剩余时间-1或正计时+1，在main函数里写延时；还要有转换器，即将computer time转化为秒，再转化为时分秒；还要有暂停回复时间的机制，让暂停后，又继续的时间保持不变，大致就这些。 绘图方面，自己看着画吧。 交互方面，就用EasyX自带的函数 代码Timer.h123456789101112131415161718192021222324252627282930313233343536373839404142#pragma once#include &lt;graphics.h&gt;#include &lt;string&gt;#include &lt;ctime&gt;#define WIDTH 700#define HEIGHT 300#define FFWIDTH 100#define FHEIGHT 100#define FTIP 50#define OFFSET 10#define CLEAN 233//position of Hourextern RECT hour_rect;//posistion of the division between Hour and Minuteextern RECT HM_sprt;extern RECT min_rect;extern RECT MS_sprt;extern RECT sec_rect;//position of the tip in the centerextern RECT tip_rect;extern RECT tip_clean;extern LOGFONT F;class TimerLogic;class TimerDrawer;class Interaction;//Timer Stateenum TimerMode &#123; COUNT_UP, COUNT_DOWN&#125;;enum TimerStatus &#123; START, RUN, STOP, WAIT, DOWNEND, RESET, EXIT&#125;;enum InputState &#123; HOR, MIN, SEC&#125;; 先将要用的东西声明出来。我们按局部到整体的方式来进行介绍。 LogicLogic.h1234567891011121314151617181920212223242526272829#pragma once#include &quot;Timer.h&quot;extern enum TimerStatus Status;class TimerLogic &#123;private: TimerMode Mode = COUNT_DOWN; int TotalSec = 0; int PauseSec = 0; int elapseSec = 0; int Interval = -1;//for the timer to count down or up clock_t ClockTime = clock();//storage the current time when pause clock_t StartTime = clock(); clock_t EndTime = clock(); bool isRunning = false; bool isPause = false; bool isZero = false; int toTotalSec(int h, int m, int s); int toSec(clock_t time); clock_t toCmpTime(int time); clock_t getCurCmpTime();public: void startTimer(int InputHor, int InputMin, int InputSec, TimerMode Mode); void stopResume(); void updateTimer(); void getCurrentTime(int&amp; hour, int&amp; min, int&amp; sec); void resetTimer(); bool isFinish();&#125;; 命名比较直接，故不详细介绍，有些变量是后期没处理好，但还是保留了，有需要可以自行修改。其实有点懒，时间不太够 Logic.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &quot;Logic.h&quot;//Some functions to convert databool TimerLogic::isFinish() &#123; return(isZero ? true : false);&#125;int TimerLogic::toTotalSec(int h, int m, int s) &#123; return h * 3600 + m * 60 + s;&#125;int TimerLogic::toSec(clock_t time) &#123; return time / CLOCKS_PER_SEC;&#125;clock_t TimerLogic::toCmpTime(int time) &#123; return time * CLOCKS_PER_SEC;&#125;clock_t TimerLogic::getCurCmpTime() &#123; return clock();&#125;void TimerLogic::startTimer(int InputHor, int InputMin, int InputSec, TimerMode Mode) &#123; this-&gt;Mode = Mode; PauseSec = 0; isRunning = true; switch (this-&gt;Mode) &#123; case COUNT_DOWN: Interval = -1; TotalSec = toTotalSec(InputHor, InputMin, InputSec);//calculate to seconds StartTime = getCurCmpTime(); EndTime = StartTime + toCmpTime(TotalSec);//calculate the end time break; case COUNT_UP: StartTime = getCurCmpTime(); Interval = 1;//for count up default: break; &#125;&#125;void TimerLogic::stopResume() &#123; if (!isRunning) return; if (Status == RUN) &#123; ClockTime = getCurCmpTime();//update the time for stop isPause = false; PauseSec = 0; &#125; if (Status == STOP) &#123; PauseSec = toSec(getCurCmpTime() - ClockTime);//update the pause interval isPause = true; &#125;&#125;void TimerLogic::updateTimer() &#123; if (!isRunning || isPause || Status == STOP) return; EndTime += PauseSec;//update new end time if (TotalSec == 0&amp;&amp;Mode == COUNT_DOWN) &#123; TotalSec = 0; Status = START; return; &#125; TotalSec += Interval;//-1 or +1&#125;void TimerLogic::getCurrentTime(int&amp; hour, int&amp; min, int&amp; sec) &#123; if (!isRunning) return; ClockTime = clock(); hour = TotalSec / 3600; min = (TotalSec - (3600 * hour)) / 60; sec = TotalSec - 3600 * hour - 60 * min;&#125;void TimerLogic::resetTimer() &#123; isRunning = false; isPause = false; TotalSec = 0; PauseSec = 0; Status = START;&#125; 解释批注均已在代码中注明，感兴趣可自行研究。 DisplayDisplay.h1234567891011121314151617181920212223#pragma once#include &quot;Timer.h&quot;extern enum TimerStatus Status;class TimerDrawer &#123;private: //To change the font size of the EasyX void toTipSize(LOGFONT F); void toClockSize(LOGFONT F); void toModeSize(LOGFONT F); RECT ConvertRect(RECT rect, float WHeight, float WWidth); float RatioW = 1; float RatioH = 1;public: void DrawLandscape(); void DrawClock(int h, int m, int s); void CleanCanva(); void CleanTip(); void CleanMode(); void DrawTip(std::wstring tip, LOGFONT F); void DrawMode(std::wstring mode, LOGFONT); void toConvert(float width, float height);&#125;; Display.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#pragma once#include &quot;Display.h&quot;RECT hour_rect = &#123; 0,0,280,300 &#125;;//posistion of the division between Hour and MinuteRECT HM_sprt = &#123; 0,0,500,300 &#125;;RECT min_rect = &#123; 0,0,720,300 &#125;;RECT MS_sprt = &#123; 0,0,920,300 &#125;;RECT sec_rect = &#123; 0,0,1120,300 &#125;;//position of the tip in the centerRECT tip_rect = &#123; 20,200,680,280 &#125;;RECT mode_rect = &#123; 500,20,680,100 &#125;;RECT tip_clean_rect = &#123; 20, 20, 680, 100 &#125;;RECT clock_recct = &#123; 10,10,690,290 &#125;;//converted rectRECT hour_rect_convert = &#123;0,0,0,0&#125;;RECT HM_sprt_convert = &#123; 0,0,0,0 &#125;;RECT min_rect_convert = &#123; 0,0,0,0 &#125;;RECT MS_sprt_convert = &#123; 0,0,0,0 &#125;;RECT sec_rect_convert = &#123; 0,0,0,0 &#125;;RECT tip_rect_convert = &#123; 0,0,0,0 &#125;;RECT mode_rect_convert = &#123; 0,0,0,0 &#125;;RECT tip_clean_rect_convert = &#123; 0,0,0,0 &#125;;RECT clock_rect_convert = &#123; 0,0,0,0 &#125;;void TimerDrawer::toTipSize(LOGFONT F) &#123; F.lfHeight = FTIP * RatioH; settextstyle(&amp;F);&#125;void TimerDrawer::toModeSize(LOGFONT F) &#123; F.lfHeight = FTIP * RatioH; settextstyle(&amp;F);&#125;void TimerDrawer::toClockSize(LOGFONT F) &#123; F.lfHeight = FHEIGHT * RatioH; settextstyle(&amp;F);&#125;// to handle the window resizingRECT TimerDrawer::ConvertRect(RECT rect,float WWidth,float WHeight) &#123; RatioH = WHeight / HEIGHT; RatioW = WWidth / WIDTH; rect.left = rect.left * RatioW; rect.right = rect.right * RatioW; rect.top = rect.top * RatioH; rect.bottom = rect.bottom * RatioH; return rect;&#125;void TimerDrawer::DrawLandscape() &#123; solidroundrect(clock_rect_convert.left, clock_rect_convert.top, clock_rect_convert.right, clock_rect_convert.bottom, OFFSET, OFFSET);&#125;void TimerDrawer::CleanCanva() &#123; solidroundrect(clock_rect_convert.left, clock_rect_convert.top, clock_rect_convert.right, clock_rect_convert.bottom, OFFSET, OFFSET); solidrectangle(tip_rect_convert.left, tip_rect_convert.top, tip_rect_convert.right, tip_rect_convert.bottom);&#125;void TimerDrawer::CleanTip() &#123; solidrectangle(tip_clean_rect_convert.left, tip_clean_rect_convert.top, tip_clean_rect_convert.right, tip_clean_rect_convert.bottom);&#125;void TimerDrawer::CleanMode() &#123; solidrectangle(mode_rect_convert.left, mode_rect_convert.top, mode_rect_convert.right, mode_rect_convert.bottom);&#125;void TimerDrawer::DrawClock(int h, int m, int s) &#123; std::wstring hw = L&quot;&quot;; std::wstring mw = L&quot;&quot;; std::wstring sw = L&quot;&quot;; hw = std::to_wstring(h); mw = std::to_wstring(m); sw = std::to_wstring(s); toClockSize(F); drawtext(hw.c_str(), &amp;hour_rect_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE); drawtext(_T(&quot;:&quot;), &amp;HM_sprt_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE); drawtext(mw.c_str(), &amp;min_rect_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE); drawtext(_T(&quot;:&quot;), &amp;MS_sprt_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE); drawtext(sw.c_str(), &amp;sec_rect_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE);&#125;void TimerDrawer::DrawTip(std::wstring tip, LOGFONT F) &#123; toTipSize(F); CleanTip(); drawtext(tip.c_str(), &amp;tip_rect_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE);&#125;void TimerDrawer::DrawMode(std::wstring mode, LOGFONT F) &#123; toModeSize(F); CleanMode(); drawtext(mode.c_str(), &amp;mode_rect_convert, DT_CENTER | DT_VCENTER | DT_SINGLELINE);&#125;void TimerDrawer::toConvert(float width,float height) &#123; hour_rect_convert = ConvertRect(hour_rect, width, height); HM_sprt_convert = ConvertRect(HM_sprt, width, height); min_rect_convert = ConvertRect(min_rect, width, height); MS_sprt_convert = ConvertRect(MS_sprt, width, height); sec_rect_convert = ConvertRect(sec_rect, width, height); tip_rect_convert = ConvertRect(tip_rect, width, height); mode_rect_convert = ConvertRect(mode_rect, width, height); tip_clean_rect_convert = ConvertRect(tip_clean_rect, width, height); clock_rect_convert = ConvertRect(clock_recct, width, height);&#125; 相关函数可查阅EasyX官方文档，上面有更详细的解释。 InteractionInteraction.h12345678910111213141516171819202122#pragma once#include &quot;Timer.h&quot;extern enum TimerStatus Status;extern enum TimerMode Mode;class Interaction &#123;private: ExMessage Key; char Num; int Time = 0; int hi, mi, si; std::string Input = &quot;&quot;; InputState input_state = HOR;public: void GetInput(ExMessage msg); void HandleInputA(); void HandleInputB(); void HandleModeChange(); InputState GetInputState(); TimerMode GetTimerMode(); void ReturnInput(int&amp; time);&#125;; Interaction.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &quot;Interaction.h&quot;void Interaction::GetInput(ExMessage msg) &#123; peekmessage(&amp;msg, EX_KEY); if (msg.message == WM_KEYDOWN) &#123; Key = msg; &#125; else Key.vkcode = NULL; return;&#125;InputState Interaction::GetInputState() &#123; return input_state;&#125;TimerMode Interaction::GetTimerMode() &#123; return Mode;&#125;void Interaction::HandleInputA() &#123; Time = 0; if (Key.vkcode &gt;= &#x27;0&#x27; &amp;&amp; Key.vkcode &lt;= &#x27;9&#x27;) &#123; Num = (char)Key.vkcode; if (Input.length() &lt; 2) &#123; Input += Num; Time = std::stoi(Input); &#125; &#125; switch (Key.vkcode) &#123; case VK_BACK: Time = CLEAN; return; case 68: case VK_RIGHT: Time = 0; input_state = (InputState)((input_state + 1) % 3); Input = &quot;&quot;; return; case 65: case VK_LEFT: Time = 0; input_state = (InputState)((input_state + 2) % 3); Input = &quot;&quot;; return; default: break; &#125; if (input_state == SEC &amp;&amp; Input.length() == 2) &#123; Status = RUN; input_state = HOR; Input = &quot;&quot;; &#125;&#125;void Interaction::HandleInputB() &#123; if (Key.vkcode == 80) &#123; if (Status == RUN) &#123; Status = STOP; &#125; else if (Status == STOP) &#123; Status = RUN; &#125; &#125; if (Key.vkcode == 82) &#123; Status = RESET; &#125; if (Key.vkcode == VK_ESCAPE || Key.vkcode == 88) Status = EXIT;&#125;void Interaction::HandleModeChange() &#123; if (Key.vkcode == 77) &#123; Mode = (TimerMode)((Mode + 1) % 2); &#125; if (Key.vkcode == VK_RETURN&amp;&amp;Status == START) &#123; Status = RUN; input_state = HOR; Time = 0; Input = &quot;&quot;; return; &#125;&#125;void Interaction::ReturnInput(int&amp; time) &#123; if (Time == CLEAN) &#123; Time = 0; time = 0; Input = &quot;&quot;; return; &#125; if (Time == 0&amp;&amp;time != 0) &#123; time = time; return; &#125; time = Time;&#125; 至于为什么两套交互逻辑，应为如果发放在同一个函数，用switch来对应逻辑未免太过冗长，且不易修改。分开来还更利于理解。 Main123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &quot;Timer.h&quot;#include &quot;Display.h&quot;#include &quot;Logic.h&quot;#include &quot;Interaction.h&quot;extern float WWidth;extern float WHeight;TimerStatus Status = START;//statementTimerMode Mode = COUNT_DOWN;TimerLogic logic;TimerDrawer draw;Interaction inter;LOGFONT F;ExMessage msg;const int delay = 1 * CLOCKS_PER_SEC;int h, m, s;float WidthofWin = 300;float HeightofWin = 100;static RECT border_thickness;std::wstring tip = L&quot;&quot;;std::wstring mode = L&quot;DOWN&quot;;clock_t start_time = clock();clock_t end_time = clock();//handle exitWNDPROC WndProc = nullptr;HWND hwnd = nullptr;LRESULT CALLBACK WindowProc(HWND hwnd, UINT u_msg, WPARAM wParam, LPARAM lParam)&#123; if (u_msg == WM_CLOSE) &#123; exit(0); &#125; else &#123; LRESULT result = CallWindowProc((WNDPROC)WndProc, hwnd, u_msg, wParam, lParam); return result; &#125;&#125;//to handle the action of closing the window//statement of functionvoid Init();void Graphic(int h, int m, int s, std::wstring tip);void Preparation();#if DEBUGint main();#elseint WinMain(HINSTANCE hInstace, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);#endif // DEBUGint main()&#123; Init(); BeginBatchDraw(); while (Status == START) &#123; Preparation(); logic.startTimer(h, m, s, Mode); while (Status == RUN || Status == STOP) &#123; start_time = clock(); tip = L&quot;&quot;; if (logic.isFinish()) break; inter.GetInput(msg); inter.HandleInputB(); logic.updateTimer(); logic.stopResume(); if (Status == STOP) tip = L&quot;Pause&quot;; if (Status == RESET) &#123; tip = L&quot;RESET&quot;; Graphic(h, m, s, tip); logic.resetTimer(); &#125; logic.getCurrentTime(h, m, s); Graphic(h, m, s, tip); FlushBatchDraw(); printf(&quot;%d %d %d\\n&quot;, h, m, s); end_time = clock(); Sleep(delay - (end_time - start_time) &gt; 0 ? delay - (end_time - start_time) : 0); &#125; &#125; Sleep(100); tip = L&quot;Exiting...&quot;; Graphic(h, m, s, tip); printf(&quot;Exiting...&quot;); FlushBatchDraw(); EndBatchDraw(); Sleep(1000); return 0;&#125;int WinMain(HINSTANCE hInstace, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; Init(); BeginBatchDraw(); while (Status != EXIT) &#123; Preparation(); logic.startTimer(h, m, s, Mode); if (Status == RESET) Status = START; while (Status == RUN || Status == STOP) &#123; start_time = clock(); tip = L&quot;&quot;; inter.GetInput(msg); inter.HandleInputB(); logic.updateTimer(); logic.stopResume(); if (Status == STOP) tip = L&quot;Pause&quot;; if (Status == RESET) &#123; tip = L&quot;RESET&quot;; Graphic(h, m, s, tip); logic.resetTimer(); FlushBatchDraw(); Sleep(200); &#125; logic.getCurrentTime(h, m, s); Graphic(h, m, s, tip); FlushBatchDraw(); end_time = clock(); if(Status == RUN) Sleep(delay - (end_time - start_time) &gt; 0 ? delay - (end_time - start_time) : 0); &#125; &#125; Sleep(100); tip = L&quot;Exiting...&quot;; Graphic(h, m, s, tip); FlushBatchDraw(); EndBatchDraw(); Sleep(1000); return 0;&#125;//definition of the functionvoid Init() &#123; printf(&quot;Init...\\n&quot;); draw.toConvert(WidthofWin,HeightofWin);#if DEBUG initgraph(WidthofWin,HeightofWin,EX_SHOWCONSOLE);#else initgraph(WidthofWin,HeightofWin);#endif gettextstyle(&amp;F); F.lfHeight = FFWIDTH; settextstyle(&amp;F); hwnd = GetHWnd(); SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED); WndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC); SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)WindowProc); draw.CleanCanva(); draw.DrawLandscape();&#125;void Graphic(int h, int m, int s, std::wstring tip) &#123; draw.toConvert(WidthofWin,HeightofWin); draw.DrawLandscape(); draw.DrawClock(h, m, s); draw.DrawTip(tip, F); draw.DrawMode(mode, F);&#125;void Preparation() &#123; h = 0, m = 0, s = 0; while (Status == START) &#123; inter.GetInput(msg); inter.HandleModeChange(); inter.HandleInputA(); inter.HandleInputB(); if (Mode == COUNT_UP) mode = L&quot;UP&quot;; if (Mode == COUNT_DOWN) mode = L&quot;DOWN&quot;; if (Status == RUN) &#123; inter.ReturnInput(s); break; &#125; switch (inter.GetInputState()) &#123; case HOR: inter.ReturnInput(h); tip = L&quot;HOR&quot;; break; case MIN: inter.ReturnInput(m); tip = L&quot;MIN&quot;; break; case SEC: inter.ReturnInput(s); tip = L&quot;SEC&quot;; break; &#125; Graphic(h, m, s, tip); FlushBatchDraw(); Sleep(100); &#125; tip = L&quot;&quot;;&#125; 其实读者细看代码，就会发现有两大段重复的代码，这里解释一下，为了方便debug和release,我写了两个main函数，分别对应debug和release，debug版本会显示控制台，release版本不会，但也会发现代码有重复，于是，写这篇文章时，我将其重写为一下的样子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &quot;Timer.h&quot;#include &quot;Display.h&quot;#include &quot;Logic.h&quot;#include &quot;Interaction.h&quot;extern float WWidth;extern float WHeight;TimerStatus Status = START;//statementTimerMode Mode = COUNT_DOWN;TimerLogic logic;TimerDrawer draw;Interaction inter;LOGFONT F;ExMessage msg;const int delay = 1 * CLOCKS_PER_SEC;int h, m, s;float WidthofWin = 500;float HeightofWin = 200;static RECT border_thickness;std::wstring tip = L&quot;&quot;;std::wstring mode = L&quot;DOWN&quot;;clock_t start_time = clock();clock_t end_time = clock();//handle exitWNDPROC WndProc = nullptr;HWND hwnd = nullptr;LRESULT CALLBACK WindowProc(HWND hwnd, UINT u_msg, WPARAM wParam, LPARAM lParam)&#123; if (u_msg == WM_CLOSE) &#123; exit(0); &#125; else &#123; LRESULT result = CallWindowProc((WNDPROC)WndProc, hwnd, u_msg, wParam, lParam); return result; &#125;&#125;//statement of functionvoid Init();void Graphic(int h, int m, int s, std::wstring tip);void Preparation();void Exit();void RunTime();#if DEBUGint main();#elseint WinMain(HINSTANCE hInstace, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);#endif // DEBUGint main()&#123; Init(); BeginBatchDraw(); RunTime(); Exit(); return 0;&#125;int WinMain(HINSTANCE hInstace, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; Init(); BeginBatchDraw(); RunTime(); Exit(); return 0;&#125;//definition of the functionvoid Init() &#123; printf(&quot;Init...\\n&quot;); draw.toConvert(WidthofWin,HeightofWin);#if DEBUG initgraph(WidthofWin,HeightofWin,EX_SHOWCONSOLE);#else initgraph(WidthofWin,HeightofWin);#endif gettextstyle(&amp;F); F.lfHeight = FFWIDTH; settextstyle(&amp;F); hwnd = GetHWnd(); SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED); WndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC); SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)WindowProc); draw.CleanCanva(); draw.DrawLandscape();&#125;void Graphic(int h, int m, int s, std::wstring tip) &#123; draw.toConvert(WidthofWin,HeightofWin); draw.DrawLandscape(); draw.DrawClock(h, m, s); draw.DrawTip(tip, F); draw.DrawMode(mode, F);&#125;void Preparation() &#123; h = 0, m = 0, s = 0; while (Status == START) &#123; inter.GetInput(msg); inter.HandleModeChange(); inter.HandleInputA(); inter.HandleInputB(); if (Mode == COUNT_UP) mode = L&quot;UP&quot;; if (Mode == COUNT_DOWN) mode = L&quot;DOWN&quot;; if (Status == RUN) &#123; inter.ReturnInput(s); break; &#125; switch (inter.GetInputState()) &#123; case HOR: inter.ReturnInput(h); tip = L&quot;HOR&quot;; break; case MIN: inter.ReturnInput(m); tip = L&quot;MIN&quot;; break; case SEC: inter.ReturnInput(s); tip = L&quot;SEC&quot;; break; &#125; Graphic(h, m, s, tip); FlushBatchDraw(); Sleep(100); &#125; tip = L&quot;&quot;;&#125;void Exit()&#123; Sleep(100); tip = L&quot;Exiting...&quot;; Graphic(h, m, s, tip); FlushBatchDraw(); EndBatchDraw(); Sleep(1000);&#125;void RunTime() &#123; while (Status != EXIT) &#123; Preparation(); logic.startTimer(h, m, s, Mode); if (Status == RESET) Status = START; while (Status == RUN || Status == STOP) &#123; start_time = clock(); tip = L&quot;&quot;; inter.GetInput(msg); inter.HandleInputB(); logic.updateTimer(); logic.stopResume(); if (Status == STOP) tip = L&quot;Pause&quot;; if (Status == RESET) &#123; tip = L&quot;RESET&quot;; Graphic(h, m, s, tip); logic.resetTimer(); FlushBatchDraw(); Sleep(200); &#125; logic.getCurrentTime(h, m, s); #ifdef DEBUG printf(&quot;%d %d %d\\n&quot;, h, m, s); #endif // DEBUG Graphic(h, m, s, tip); FlushBatchDraw(); end_time = clock(); if (Status == RUN) Sleep(delay - (end_time - start_time) &gt; 0 ? delay - (end_time - start_time) : 0); &#125; &#125;&#125;其中12345678switch (inter.GetInputState()) &#123; case HOR: inter.ReturnInput(h); tip = L&quot;HOR&quot;; break; case MIN: inter.ReturnInput(m); tip = L&quot;MIN&quot;; break; case SEC: inter.ReturnInput(s); tip = L&quot;SEC&quot;; break; &#125;这是最让我抓狂的地方，因为总是有奇奇怪怪的问题，不过，现在看来其实有更好的办法，只要让ReturnInput()先读取h,m,s的值然后再处理，会简单的多，但当时我没想到，拼命把ReturnInput()初始化为0然后用一大堆逻辑关系来阻止h,m,s的值的改变，现在看来，有点笨，读者可自行修改，后面我将进行修改。 总结这次项目，我尝试按照一定的规范，用多文件，坚持清晰，无误的目的，完成了这次编写。过程收获了很多，虽然可能过程曲折一点，时间久一点，代码水平也没那么高，不过，我还是想将此项目介绍给读者，虽然也没人看，但这个记录，就是我成长的足迹。我没想过当程序员在未来，这只不过是兴趣，不过我仍然愿意挤出时间（玩游戏的）在高中繁忙的学业中，学习有关技术，当然是在保证学习的情况下进行的。我知道有很多同龄人他们比我强上万倍（如写自制语言编译器的），我会自卑，但不会放弃，我会继续努力，继续精进，精益求精。写的比较匆忙，后期可能考虑详细说明。项目地址Clock","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"EasyX","slug":"C-C/EasyX","permalink":"https://linikc.github.io/categories/C-C/EasyX/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"EasyX","slug":"EasyX","permalink":"https://linikc.github.io/tags/EasyX/"}],"author":"Linik"},{"title":"Rotate_Cube","slug":"Rotate-Cube","date":"2025-06-02T09:26:12.000Z","updated":"2025-09-14T07:15:17.966Z","comments":true,"path":"2025/06/02/Rotate-Cube/","link":"","permalink":"https://linikc.github.io/2025/06/02/Rotate-Cube/","excerpt":"","text":"Rotate CubeFormulaThe basis of this function这个是窗口X坐标 OK，前期准备就绪 Structure12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;graphics.h&gt;#include &lt;math.h&gt;struct Point[8]&#123; &#123;-50,-50,-50&#125;,//0 &#123;50,-50,-50&#125;,//1 &#123;50,50,-50&#125;,//2 &#123;-50,50,-50&#125;,//3 &#123;-50,-50,50&#125;,//4 &#123;50,-50,50&#125;,//5 &#123;50,50,50&#125;,//6 &#123;-50,50,50&#125;//7 the postition of the point of the cube&#125;;int edge[12][2]&#123; &#123;0,1&#125;,&#123;0,3&#125;,&#123;0,4&#125;,&#123;1,2&#125;,&#123;1,5&#125;,&#123;1,7&#125;,&#123;2,3&#125;,&#123;2,6&#125;,&#123;3,7&#125;,&#123;4,5&#125;,&#123;5,6&#125;,&#123;6,7&#125;&#125;;//line the pointPoint Newcube[8];POINT ScrPoi [8];float thetaY = 0.0f;float thetaX = 0.0f;float rotatedX = 0.0f;float rotatedZ = 0.0f;float factor = 0.0f;float d = 300.0f;//焦距大概void KeyGet();void Handle();void Display();int main()&#123; initgraph(800,800); setbkcolor(BLACK); cleardevice(); Display(); while(true) &#123; GetKey(); Handle(); Display(); &#125; closegraph(); return 0;&#125; 可以看到，这是基本的框架，至于为什么要有Newcube这个新的变量，主要是因为与原来的数据做区分，防止数据污染，串行啥的导致计算结果出现问题。 具体看一下各个函数 GetKey()1234567891011121314151617void GetKey()&#123; ExMessage msg; while(true) while(peekmessage(&amp;msg,EX_KEY)) switch(msg.message) case WM_KEYDOWN: if(msg.vkcode == &#x27;A&#x27;)//turn left thetaY -= 0.1f; if(msg.vkcode == &#x27;D&#x27;)//turn right thetaY += 0.1f; if(msg.vkcode == &#x27;W&#x27;)//turn down I write wrong, You can change it. thetaX -=0.1f; if(msg.vkcode == &#x27;S&#x27;) thetaX +=0.1f; return;&#125; 比较好理解，不做解释了 Handle()1234567891011121314151617void Handle()&#123; for(int i = 0, i &lt; 8,i++) &#123; rotatedX = cube[i].x*cos(thetaY) - cube[i].z*sin(thetaY); rotatedZ = cube[i].x*sin(thetaY) - cube[i].z*cos(thetaY); Newcube[i].x = rotatedX; Newcube[i].y = cube[i].y*cos(thetaX) - rotaedZ*sin(thetaX); Newcube[i].z = cube[i].y*sin(thetaX) + rotaedZ*cos(thetaX); &#125; for(int i = 0;i &lt; 8;i++)//tansform the 3D position to 2D position &#123; factor = d/(Newcube[i].z + d); ScrPoi[i].x = (int)(Newcube[i].x * factor) + 400;//400 is the Center x-position of the Screen ScrPoi[i].y = (int)(Newcube[i].y * factor) + 400;//the same &#125;&#125; Display()123456789101112void Display()&#123; cleardevice(); BeginBatchDraw(); setlinecolor(WHITE); for(int n = 0;n &lt; 14;n++) &#123; line(ScrPoi[edge[n][0]].x,ScrPoi[edge[n][0]].y,ScrPoi[edge[n][1]].x,ScrPoi[edge[n][1]].y); &#125; FlushBatchDraw(); EndBatchDraw();&#125; BeginBatchDraw()根据官方文档来看是指暂停实时绘画，等到EndBatchDraw()再显示到屏幕上。FlushBatchDraw()来更新。 这个是根据图形学的坐标系，z轴不是我们常见的高度，而是指视线前的物体到视角的距离 原理坐标旋转利用到高一就学过的三角函数知识即可求解","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"EasyX","slug":"C-C/EasyX","permalink":"https://linikc.github.io/categories/C-C/EasyX/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"EasyX","slug":"EasyX","permalink":"https://linikc.github.io/tags/EasyX/"}],"author":"Linik"},{"title":"Win32-2","slug":"Win32-2","date":"2024-09-01T06:04:13.000Z","updated":"2025-06-02T07:49:51.590Z","comments":true,"path":"2024/09/01/Win32-2/","link":"","permalink":"https://linikc.github.io/2024/09/01/Win32-2/","excerpt":"","text":"Win32 2Handle Message继续跟着theForger sensei的教程走,我们接着学习消息处理 本节的实例是点击窗口然后MessageBox告诉你这个程序的目录，之后exit当然本节不需要改变其他部分，只要改变WndProc()就可以了1234567891011121314LRESULT CALLBACK WndProc(HWND hwnd,Uint mg,WParam wParam,LParam lParam)&#123; switch(msg) &#123; case: WM_LBUTTONDOWN: &#123; char* FileName[MAX_PATH]; HINSTANCE hInstance = GetModuleHandle(NULL); GetModuleFileName(hInstance, FileName, MAX_PATH); MessageBox(hwnd, FileName, L&quot;This Program is:&quot;, MB_OK | MB_ICONINFORMATION); &#125;break; ... &#125;return 0;&#125;MAX_PATH 此项为“最大路径长度限制”为260个字符，但实际上为259个（不包括结束符）所以文件名不要写太长，文件不要藏太深，不然删不掉。GetModuleHandle(NULL) 获取当前程序的实例句柄,准确来说是给一个NULL返回一个创建发出调用进程的文件句柄GetModuleFileName(hInstance, FileName, MAX_PATH) 获取当前程序的文件路径MessageBox 就不用解释了 Have a try on your computer Message Loop理解消息循环 所谓消息，“就是一个整数”，是数字，数值。只不过，我们用宏定义将消息的数值用字符表示、替换，由于其为宏定义，在编译之前就会将所有的字符换回数值再进行编译123456789101112131415161718192021#define WM_SETFOCUS 0x0007#define WM_KILLFOCUS 0x0008#define WM_ENABLE 0x000A#define WM_SETREDRAW 0x000B#define WM_SETTEXT 0x000C#define WM_GETTEXT 0x000D#define WM_GETTEXTLENGTH 0x000E#define WM_PAINT 0x000F#define WM_CLOSE 0x0010#ifndef _WIN32_WCE#define WM_QUERYENDSESSION 0x0011#define WM_QUERYOPEN 0x0013#define WM_ENDSESSION 0x0016#endif#define WM_QUIT 0x0012#define WM_ERASEBKGND 0x0014#define WM_SYSCOLORCHANGE 0x0015#define WM_SHOWWINDOW 0x0018#define WM_WININICHANGE 0x001A这是WinUser.h文件，其中可以明显看到我们所写的消息名称都将会替换为对应的16位数字每一个操作，事件都会产生对应的消息，被加入消息队列,被翻译，被发送，被处理123456while(GetMessage(&amp;msg, NULL, 0, 0) &gt; 0)&#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg);&#125;return msg.wParam;这个代码很好解释了消息处理的过程:Get-&gt;Translate-&gt;Dispatch-&gt;Handle就是这么一个过程值得注意的是：GetMessage 会返回 正数 0 负数 正数 正常 0 程序退出 负数 错误！！！！！！ 所以不能用一下方法书写12345while(GetMessage(&amp;msg, NULL, 0, 0))while(GetMessage(&amp;msg,NULL,0,0,) == TRUE)while(GetMessage(&amp;msg,NULL,0,0) != 0)当然，你能保证完全不出任何错误，就可以这么写，但是，这是不推荐的 消息也有两个参数: wParam(16bit), lParam(32bit)当然，也可以都没有e.g.WM_CLOSE也可以都有e.g.WM_COMMAND WM 是 Window Message的缩写PS:Param 是Parametric adj. 参数的 缩写（Parameric重音在后metric），个人感觉指代Parameter n.参数更合适（Parameter重音在前rameter）区别： wParam: 有两个部分HIWORD(wParam) 包含提示消息 LOWORD(wParam) 包含发送消息的控件或菜单的标识号 lParam: 含有发送消息控件的hwnd or NULL（消息不是控件发的） HIWORD: 高位的十六位字节 LOWORD: 低位的十六位字节 即四字节（32bit）的前两位为一WORD(16bit)e.g. 0xCCDDEEFF HIWORD: 0xCCDD LOWORD: 0xEEFFDWORD 32bit (double WORD) Use Resources资源：程序运行时所需要的文件，如图标、光标、菜单、对话框、字符串等 AI的definition本节，我们将学习如何编写资源脚本（当然，你用VisualStudio的话，也可以不学的，毕竟学起来也头大的bushi） resource.h1#include &quot;resource.h&quot; 直接include 1#define IDI_MYICON 101//随便写一个标识符 111，2001，9001都可以 Resource.rc文件这个文件，不是C语言，相当于一个文本文件，用来描述资源，编译器不会检查错误，只有在编译阶段报错才知道哪里写错了 ICON1IDI_MYICON ICON &quot;myicon.ico&quot;//图标文件,记得换一下名 123//修改图标HICON MYICON = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MYICON));wclass.hIcon = MYICON;//LoadIcon(NULL, IDI_APPLICATION); MENU 菜单1#define IDR_MYMENU 103 12345IDR_MYMUNU MENUBEGIN POPUP &quot;File&quot; POPUP &quot;Help&quot;END 1wclass.lpszMenuName = MAKEINTRESOURCE(IDR_MYMENU);//记得修改 效果如下图所示如果想要二级菜单的话，就再套一个BEGIN 和 END12345678910IDR_MYMUNU MENUBEGIN POPUP &quot;File&quot; BEGIN MENUITEM &quot;New&quot;, 1001 MENUITEM &quot;Open&quot;, 1002 MENUITEM &quot;Save&quot;, 1003 END POPUP &quot;Help&quot;END DIALOG 对话框1#define IDD_ABOUT 104 稍微复杂一点1234567891011121314151617IDD_ABOUT DIALOG DISCARDABLE 0, 0, 240, 120STYLE DS_MODALFRAME | WS_CAPTION | WS_SYSMENUCAPTION &quot;About Page&quot;FONT 8, &quot;System&quot;BEGIN LTEXT &quot;This is a test.&quot;, -1, 10, 20, 100, 10 DEFPUSHBUTTON &quot;OK&quot;, 1, 190, 20, 50, 14ENDIDR_MYMUNU MENUBEGIN POPUP &quot;File&quot; BEGIN MENUITEM &quot;About&quot;, ID_FILE_ABOUT END POPUP &quot;Help&quot;END1#define ID_FILE_ABOUT 105main.c12345678910111213141516171819202122232425LRESULT CALLBACK ABOUT_Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; switch(msg) &#123; case WM_INITDIALOG:TRUE; case WM_COMMAND: &#123; switch LOWORD(wParam): case IDOK: EndDialog(hwnd, wParam);break; &#125;break; default: return FALSE; &#125;return TRUE;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; switch(msg) &#123; ... case ID_FILE_ABOUT &#123; int ret = DialogBox(GetMoudleHandle(NULL), MAKEINTRESOURCE(IDD_ABOUT), hwnd, ABOUT_Proc); &#125; &#125;&#125;效果如下图所示 InteractionWait Wait Wait. 我发现这个教程有点简单了，只做了基本的介绍，同时加上我的时间紧张but I promise to handle this issue这个简单的教程可能现告一段落了，之后会补的（当我有相关基础时","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Win32","slug":"C-C/Win32","permalink":"https://linikc.github.io/categories/C-C/Win32/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"Win32","slug":"Win32","permalink":"https://linikc.github.io/tags/Win32/"}],"author":"Linik"},{"title":"SDL 2D Game Platform","slug":"SDL-2D-Game-Platform","date":"2024-07-30T12:58:43.000Z","updated":"2024-09-06T10:37:07.620Z","comments":true,"path":"2024/07/30/SDL-2D-Game-Platform/","link":"","permalink":"https://linikc.github.io/2024/07/30/SDL-2D-Game-Platform/","excerpt":"","text":"SDL2 2D 平台游戏(Platfrom)Platform &amp; Background平台游戏(Platform),就是马里奥，猫里奥一类的平台移动跳跃游戏，难度不是很大可能吧。在学习了SDL2后边写边学的，加之以前GameMaker2的试试水,以及对Unity的摆烂不想学习，所以决定用SDL2手搓出Platform，顺便了解SDL2不然没有动力，毅力去学不多说了，开始 Libraries SDL2 SDL2_image SDL2_ttf1234#include &lt;SDL.h&gt;#include &lt;SDL_image.h&gt;#include &lt;SDL_ttf.h&gt;#include &lt;string&gt; InitGlobal Statement后面会加先别急12345678const int WIDTH = 1500;const int HEIGHT = 800;SDL_Surface* Screen = NULL;SDL_Surface* bg = NULL;//Background pic loadSDL_Window* Window = NULL;//Window SDL_Surface* Player = NULL;SDL_Surface* Wall = NULL;SDL_Event event;//不用加* Init()123456789101112131415161718bool Init()&#123; SDL_Init(SDL_INIT_EVERYTHING); IMG_Init(IMG_INIT_PNG); Window = SDL_CreatWindow(&quot;NAME&quot;, SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,//也可以是具体数据SDL_WINDOWPOS_UNDEFINED就是默认位置，SDL_WINDOWPOS_CENTERED居中 WIDTH,HEIGHT, SDL_WINDOW_SHOWN);//SDL_WINDOW_SHOWN显示窗口 Screen = SDL_GetWindowSurface(Window);//Bind Window if(Screen == NULL) &#123; printf(&quot;Surface Load ERROR: %s\\n&quot;,SDL_GetError()); return false; &#125; SDL_UpdateWindowSurface(Window);//更新 printf(&quot;INIT OVER&quot;); return true;&#125; Load AssetLoadImg()加载,去背景并优化123456789101112131415161718192021SDL_Surface* LoadImg(std::string path)&#123; SDL_Surface* Load = NULL; SDL_Surface* Optimized = NULL; Load = IMG_Load(path.c_str()); if(Load == NULL) &#123; printf(&quot;%s Load ERROR: \\n Problem:%s\\n&quot;,path.c_str(),IMG_GetError()); return 0; &#125; else &#123; Optimized = SDL_ConvertSurface(Load,Screen-&gt;format,0);//进行转换 SDL2的方法 SDL_free(Load);//释放Load &#125; Uint32 ColorKey = SDL_MapRGB(Optimized-&gt;format,0,0,0)//去黑色背景(...0,0,0)为相应的颜色RGB代码 SDL_SetColorKey(Optimized,SDL_TRUE,ColorKey);//SDL_TRUE的值为1表示进行除背景 printf(&quot;Load %s\\n&quot;,path.c_str()); return Optimized; SDL_free(Optimized);//应该有用吧？&#125; 暂时没有弄字体LoadAsset()123456void LoadAsset()&#123; bg = LoadImg(&quot;asset/bg.png&quot;);//路径自己要改呀，不要照抄 Player = LoadImg(&quot;asset/player.png&quot;); Wall = LoadImg(&quot;asser/wall.png&quot;);&#125; Applypic()放置图片由于不想用int x,y;这么麻烦，又不想用SDL_Rect，所以我自己定义了一个结构后面抓狂之处 struct position{ int x = 0; int y = 0; postition(int x,int y): x(x), y(y) {}}; 很熟悉吧，从贪吃蛇借的事实证明这是错的，可将下文的position用SDL_Rect代替继续12345678void Applypic(SDL_Surface* pic,SDL_Surface* destn,position pos)&#123; //加一个目标Surface更严谨一点 SDL_Rect offset; offset.x = pos.x; offset.y = pos.y; SDL_BlitSurface(pic,NULL,destn,&amp;offset);&#125; Main()int main()1234567891011int main(int argc,char* args[])//祖传开头&#123; if(!Init()) return 0; LoadAsset() Applypic(bg,Screen,position(0,0));//放置背景，当然可以单独声明个全局变量 SDL_UpdateWindowSurface(Window); Loop(); SYSQuit(); return 0;&#125; SYSQuit()123456789void SYSQuit()&#123; SDL_free(bg); SDL_free(Player); SDL_free(Wall); SDL_DestroyWindow(Window); IMG_Quit(); SDL_Quit();&#125; Loop()12345678910111213SDL_Event event;//Global Statementvoid Loop()&#123; bool quit = false; while(!quit) &#123; while(SDL_PollEvent(&amp;event)) &#123; if(event.type == SDL_QUIT) quit = true; &#125; &#125;&#125; End2024.9.1在学Win32之后再更","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Game","slug":"C-C/Game","permalink":"https://linikc.github.io/categories/C-C/Game/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"}],"author":"Linik"},{"title":"Win32 Start","slug":"Win32-start","date":"2024-07-28T05:39:20.000Z","updated":"2024-10-13T07:45:26.893Z","comments":true,"path":"2024/07/28/Win32-start/","link":"","permalink":"https://linikc.github.io/2024/07/28/Win32-start/","excerpt":"","text":"Win32 StartIntroductionWin32 是 Windows 操作系统提供的应用程序接口（API），它允许开发人员使用 C/C++ 编程语言创建 Windows 应用程序。Win32 API 提供了大量的函数和宏，用于处理窗口、图形、文件操作、网络通信等任务。AI真厉害简而言之，就是为创建Windows应用窗口提供了一个便捷的官方的方法虽然还是有点复杂话不多说，直接开始 声明全程用的是Unicode字符集，故字符串前要加上”L“不然乱码 WinMainWinMain()是整个程序的入口点，相当于我们一般写的main()。相较于main来说，WinMain的参数变多，且必须要填12345#include &lt;windows.h&gt;int WINAPI WinMain( HINSTANCE hInstace,HINSTANCE hPrevInstance, LPSTR lpCmdLine,int nCmdShow)我们来分析以上代码 HISTANCE hInstancehInstance h即handle 句柄/处理 的意思Instance 例子/实例的意思，故为实例句柄 Handle Instance计算机用来识别EXE文件身份的值 HINSTANCE hPrevInstancehPrevInstance Prev 即Previous 先前的故为先前实例句柄 Handle Previous Instance如果打开两个该EXE文件，那么第一个窗口是后者的先前实例句柄始终为NULL LPSTR lpCmdLine L Long P Pointer(指针) STR string指向一个字符串的32位指针，每个字符占1个字节,解释不下去了，用Microsoft原话:应用程序的命令行，不包括程序名称 int nCmdShow n即int类似还有b bool, c cahr ,s string , p pointer Microsoft:如果函数成功，在收到 WM_QUIT 消息时终止，它应返回该消息 wParam 参数中包含的退出值。 如果函数在输入消息循环之前终止，则应返回零OK舒一口气~继续 WNDCLASSEXWNDCLASSEX 看名字CLASS,OK 结构体，WND Window ,EX Extended 扩展的，故为窗口类扩展结构体 人话:窗口类初始化设置1234567891011121314typedef struct tagWNDCLASSEX &#123; UINT cbSize; // 结构体大小 UINT style; // 窗口类样式 WNDPROC lpfnWndProc; // 窗口过程函数 int cbClsExtra; // 窗口类附加内存 int cbWndExtra; // 窗口附加内存 HINSTANCE hInstance; // 窗口类实例句柄 HICON hIcon; // 窗口类图标 HCURSOR hCursor; // 窗口类光标 HBRUSH hbrBackground; // 窗口类背景画刷 LPCTSTR lpszMenuName; // 窗口类菜单名称 LPCTSTR lpszClassName; // 窗口类名称 HICON hIconSm; // 窗口类小图标&#125; ...看看定义稍微写写12345678910111213WNDCLASSEX wc;//不是w cwc.cbSize = sizeof(WNDCLASSEX);//结构体大小wc.style = CS_HREDRAW | CS_VREDRAW;//窗口类样式 0也可以 CS 不是 WS 下面会讲wc.lpfnWndProc = WndProc;//窗口过程函数 后面说不要急wc.cbClsExtra = 0;//窗口类附加内存 一般为0同下wc.cbWndExtra = 0;//窗口附加内存wc.hInstance = hInstance;//窗口类实例句柄wc.hIcon = LoadIcon(NULL,IDI_APPLICATION);//窗口类图标 默认的那个wc.hCursor = LoadCursor(NULL,IDC_ARROW);//窗口类光标 自己的光标了wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);//窗口类背景画刷 白色 HBRUSH HB? Brush? 还是 Hard Brush? 不知道wc.hIconSm = LoadIcon(NULL,IDI_APPLICATION);//窗口类小图标wc.lpszMenuName = NULL;//窗口类菜单名称wc.lpszClassName = L&quot;Win32&quot;;//窗口类名称窗口类名称可以用全局变量1const wchar_t g_classWName[] = L&quot;MYFWINDOWS&quot;;破案了 LPSTR 是 const wchar_t* Register注册窗口类12345if(!RegisterClassEx(&amp;wc))&#123; MessageBox(NULL,L&quot;窗口类注册失败 | Window Resgister Failed&quot;,L&quot;错误 | WRONG&quot;,MB_ICONEXCLAMATION|MB_OK); return 0;&#125;MessageBox 玩过VBS的应该知道这是显示一个消息框（弹窗）MB_ICONEXCLAMATION 是警告图标，MB_OK 是确定按钮 Create创建窗口123456789HWND hWnd;hwnd = CreateWindowEx( 0, g_classWName,//L&quot;Win32&quot;,也行 L&quot;Win32&quot;, WS_OVERLAPPEDWINDOW,//WS_OVERLAPPEDWINDOW是一个窗口式样参数 WS CW_USEDEFAULT,CW_USEDEFAULT,500,400,//x,y,w,h CW_USEDEFAULT 使用默认 4个都可以 NULL,NULL,hInstance,NULL);来来，定义来咯~12345678910111213CreateWindowExW( _In_ DWORD dwExStyle,//WS_EX_CLIENTEDGE 与 0 不知道有什么区别 _In_opt_ LPCWSTR lpClassName, _In_opt_ LPCWSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent,//父级窗口，没有，因为我就是父--级,开玩笑 _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);//窗口的创建数据记得Check123456if (hwnd == NULL)&#123; MessageBox(NULL, L&quot;窗口创建失败 | Window Creation Failed!&quot;, L&quot;错误 | Error!&quot;, MB_ICONEXCLAMATION | MB_OK); return 0; &#125; Show显示窗口12ShowWindow(hWnd,nCmdShow);//nCmdShow 可选参数 我会在之后把一些函数的参数整理一下UpdateWindow(hWnd); Message消息部分补上开头的WndProc123456789101112131415LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)//l 可以理解为local&#123; switch (message) &#123; case WM_CLOSE: DestroyWindow(hWnd); break; case WM_DESTROY:PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125; Run运行消息循环1234567MSG msg;while (GetMessage(&amp;msg, NULL, 0, 0))//任何事件会产生一个消息并推送到消息队列，那么GetMessage&#123; TranslateMessage(&amp;msg);// TranslateMessage 将消息转换为字符消息 翻译 DispatchMessage(&amp;msg);//dispatch 发送 DispatchMessage(&amp;msg);//dispatch 发送&#125; End1return (int)msg.wParam; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;windows.h&gt;const wchar_t g_classWName[] = L&quot;MYFWINDOWS&quot;;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_CLOSE: DestroyWindow(hWnd); break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; WNDCLASSEX wc; wc.cbSize = sizeof(WNDCLASSEX); wc.style = 0; wc.lpfnWndProc = WndProc; wc.cbClsExtra = 0; wc.cbWndExtra = 0; wc.hInstance = hInstance; wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wc.lpszMenuName = NULL; wc.lpszClassName = g_classWName; wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION); if (!RegisterClassEx(&amp;wc)) &#123; MessageBox(NULL, L&quot;窗口注册失败 | Window Registration Failed!&quot;, L&quot;错误 | Error!&quot;, MB_ICONEXCLAMATION | MB_OK); return 0; &#125; HWND hwnd = CreateWindowExW( 0, g_classWName, L&quot;Win32&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,CW_USEDEFAULT,500,400, NULL, NULL, hInstance, NULL ); if (hwnd == NULL) &#123; MessageBox(NULL, L&quot;窗口创建失败 | Window Creation Failed!&quot;, L&quot;错误 | Error!&quot;, MB_ICONEXCLAMATION | MB_OK); return 0; &#125; ShowWindow(hwnd, nCmdShow); UpdateWindow(hwnd); MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return (int)msg.wParam;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Win32","slug":"C-C/Win32","permalink":"https://linikc.github.io/categories/C-C/Win32/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"Win32","slug":"Win32","permalink":"https://linikc.github.io/tags/Win32/"}],"author":"Linik"},{"title":"SDL2 2","slug":"SDL2-2","date":"2024-07-06T10:59:39.000Z","updated":"2024-07-30T14:37:22.568Z","comments":true,"path":"2024/07/06/SDL2-2/","link":"","permalink":"https://linikc.github.io/2024/07/06/SDL2-2/","excerpt":"","text":"Something about SDL2除背景倘若，你有一幅图要去除其背景(黑色)123Uint32 ColorKey = SDL_MapRGB(pic-&gt;format, 0, 0, 0);//0,0,0 背景RGB代码，注意pic本身不要有与背景相同的颜色否则，你知道的SDL_SetColorKey(pic, SDL_TRUE, ColorKey);","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"SDL2","slug":"C-C/SDL2","permalink":"https://linikc.github.io/categories/C-C/SDL2/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"}],"author":"Linik"},{"title":"BrainFuck","slug":"BrainFuck","date":"2024-06-28T04:47:28.000Z","updated":"2024-07-28T05:51:58.874Z","comments":true,"path":"2024/06/28/BrainFuck/","link":"","permalink":"https://linikc.github.io/2024/06/28/BrainFuck/","excerpt":"","text":"BrainFuckIntroudectionBrainFuck(BF)正如其名,brain/fuck,它是1970年代由Ulrich von Luxburg创造的。按图灵机设计的作为一个极简的编程语言。它只有8个字符：1234567&gt; //右移指针 p++&lt; //左移指针 p--+ //所在指针的数值加1 (*p)++- //所在指针的数值减1 (*p)--. //输出所在指针的数值(ASCII码), //从输入读取一个字符，存储在所在指针[ //如果所在指针的数值为0，则跳转到对应的] Example举几个简单的例子1234,.//输入与输出[-]//清零当前指针+++[&gt;++++&lt;-]//3x4+++++[&gt;+++++++++++++&lt;-].//输出A(65) Compile至于编译器,自己看随便搜一搜就出来了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char s[30000]=&#123;0&#125;;char code[100000];int len = 0;int stack[100];int stack_len=0;int main(int argc,char**argv)&#123; char c; int i=0,j,k,x=0; FILE* f; char* p=s+10000; f=fopen(argv[1],&quot;r&quot;); while(fread(&amp;code[len],1,1,f)==1) &#123; len++; &#125; setbuf(stdout,NULL); while(i&lt;len) &#123; switch(code[i]) &#123; case &#x27;+&#x27;: (*p)++; break; case &#x27;-&#x27;: (*p)--; break; case &#x27;&gt;&#x27;: p++; break; case &#x27;&lt;&#x27;: p--; break; case &#x27;.&#x27;: putchar((int)(*p)); //printf(&quot;put:%hdn&quot;,*p); break; case &#x27;,&#x27;: *p=getchar(); break; case &#x27;[&#x27;: if(*p) &#123; stack[stack_len++]=i; &#125; else &#123; for(k=i,j=0;k&lt;len;k++) &#123; code[k]==&#x27;[&#x27;&amp;&amp;j++; code[k]==&#x27;]&#x27;&amp;&amp;j--; if(j==0)break; &#125; if(j==0) i=k; else &#123; fprintf(stderr,&quot;%s:%dn&quot;,__FILE__,__LINE__); return 3; &#125; &#125; break; case &#x27;]&#x27;: i=stack[stack_len-- - 1]-1; break; default: break; &#125; i++; //x++; //printf(&quot;%d : i=%dn&quot;,x,i); &#125; printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/categories/BF/"}],"tags":[{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/tags/BF/"}],"author":"Linik"},{"title":"Start SDL2","slug":"Start-SDL2","date":"2024-02-09T15:26:42.000Z","updated":"2024-07-06T10:56:30.000Z","comments":true,"path":"2024/02/09/Start-SDL2/","link":"","permalink":"https://linikc.github.io/2024/02/09/Start-SDL2/","excerpt":"","text":"SDL2所谓SDL2就是C++的一个图形库。用来做游戏的 配置包含目录(include)-&gt;SDL中的include文件夹库目录(lib)-&gt;SDL中的lib文件夹链接器-&gt;输入-&gt;附加依赖项 SDL2.lib SDL2main.lib问题可能编译时遇到LNK 2019的报错或[error LNK2001: 无法解析的外部符号 ___CrtDbgReportW]别问我怎么知道的 这就需要 所在的项目点右键，选择“属性” -&gt; “配置属性” -&gt; “C/C++” -&gt; “预处理器” -&gt; “预处理定义” 移除_DENUG或将 _DENUG改为NDENUG或 改成多线程调试DLL(MDd)在链接器命令行中加/NODEFAULTLIB:”libcmt.lib” Init1234#include &quot;SDL.h&quot;...int main(int argc,char* args[])... 统一的开头(up) 123456789101112131415SDL_INIT(SDL_INIT_EVERYTHING);//也可以SDL_INIT_VIDEO 差别不大 ==-1指Init 失败SDL_Suface* screen=NULL;SDL_Window* Window=NULL;//SDL2改了SDL_SetVideoModeSDL_CreateWindow(&quot;title&quot;, x,//也可以 SDL_WINDOWPOS_UNDEFINED 默认位置 y, SCREEN_WIDTH,SCREEN_HEIGHT,SDL_WINDOW_SHOWN);screen = SDL_GetWindowSurface(Window);//surface绑定...SDL_UpdateWindowSurface(Window);//updateSDL_Delay(1000);//延迟SDL_DestroyWindow(Window);SDL_Quit();//退出return 0; Load Image原生的SDL2中只能加载BMP格式的图片，只能用SDL2_image官方库加载PNG、JPG、TIFF、WebP、GIF格式的图片 下载https://github.com/libsdl-org/SDL_imagerelease中下载zip看着办 构建进入解压文件中的VisualC打开SDL_image.sln编译 Problem如果报错可能是SDL库没配置 配置include-&gt;include文件夹lib-&gt;编译生成的文件夹(debug/release) 链接器-&gt;输入-&gt;附加依赖项 SDL2.lib SDL2main.lib SDL2_image.lib IMG_Load()1234567...#include &lt;SDL_image.h&gt;...IMG_Init(IMG_INIT_PNG);//初始化SDL_Surface* surface = IMG_Load(&quot;path&quot;);//加载图片...IMG_Quit();//退出 Optimize1234567891011121314151617181920212223242526SDL_Surface* loadImage(std::string path)&#123; SDL_Surface* load = NULL; SDL_SUrface* optimized = NULL; //加载图片 load = IMG_Load(path.c_str()); if(load == NULL) &#123; fprintf(stderr, &quot;Unable to load image %s! SDL_image Error: %s\\n&quot;, path.c_str(), IMG_GetError()); return 0; &#125; else &#123; //转换图片 optimized = SDL_ConvertSurface(load, screen-&gt;format, NULL); SDL_FreeSurface(load);//释放load &#125; if(optimized == NULL) &#123; fprintf(stderr, &quot;Unable to optimize image %s! SDL Error: %s\\n&quot;, path.c_str(), SDL_GetError()); return 0; &#125; return optimized;&#125;...SDL_Surface* Image = loadImage(&quot;path&quot;); 上述代码将图片加载到内存中，并转换为屏幕的格式 Show Image1SDL_BlitSurface(Image,NULL,Surface,position); Move Image12345678910...void ApplyImage(SDL_Surface* source,SDL_Surface* destination, int x ,int y)&#123; SDL_Rect offset;//BlitSurface只接受SDL_Rect类型 offset.x = x; offset.y = y; SDL_BlitSurface(source,NULL,destination,&amp;offset);&#125;...ApplyImage(Image,Surface,100,200);//在（100，200）（其实是在100，-200的位置）的位置放图片 Events12345678910SDL_Event event;//state eventwhile(SDL_PollEvent(&amp;event))&#123; switch(event.type) &#123; case SDL_QUIT: quit = true; break; &#125;&#125; SDL_Event 不用”*”否则不兼容 Quit1234SDL_DestroyWindow(Window);//字面意思摧毁窗口SDL_Quit();//SDL exitIMG_Quit();//IMG exitreturn 0;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"SDL2","slug":"C-C/SDL2","permalink":"https://linikc.github.io/categories/C-C/SDL2/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"}],"author":"Linik"},{"title":"Gluttonous-snake","slug":"Gluttonous-snake","date":"2024-01-30T10:36:08.000Z","updated":"2025-04-06T06:47:34.906Z","comments":true,"path":"2024/01/30/Gluttonous-snake/","link":"","permalink":"https://linikc.github.io/2024/01/30/Gluttonous-snake/","excerpt":"","text":"Gluttonous Snake正所谓贪吃蛇，就是上下左右移动方形的不断变长的蛇在一个方格内吃食物的，每次吃掉一个食物，蛇的长度就增加一格的，蛇的移动速度会加快，当蛇碰到自己的身体或者边界时，游戏结束的一个游戏像废话 CMD Versioninclude12345#include &lt;iostream&gt;//not neccessity#include &lt;list&gt;#include &lt;conio.h&gt;#include &lt;random&gt;//generate random number#include &lt;time.h&gt;//get seed of random number 如上，random用来生成food&amp;snake的随机位置list用来存储snake的各个部分 Initialization1234const int WIDTH = 50;const int HEIGHT =50;//随便填int score=0;//scoreposition head; 为了方便储存xy到list中要定义一个结构12345struct position&#123; int x,y=0; position(int x,int y):x(x),y(y)&#123;&#125;;&#125;初始化坐标123list&lt;position&gt; snake;//snake&#x27;s positionposition food;//food&#x27;s positionposition snakepos;//snake&#x27;s moving direction InitGame()123456789std::srand(time(NULL));//init food positionfood.x=rand()%(WIDTH-2)+1;food.y=rand()%(HEIGHT-2)+1;//init snake positionsnake.push_back(point(WIDTH/2,HEIGHT/2));//Also, can use snake.push_back(position(rand()%(WITDH-2)+1,rand()%(HEIGHT-2)+1));snakepos.x = -1;snakepos.y =0;head=snake.front(); rand()%(n-m+1)+m指的是m与n的随机数 GameLoop()Get input12345678if(_kbhit()) switch(_getch()) &#123; case &#x27;D&#x27; : snakepos.x =1;snakepos.y =0;break; case &#x27;A&#x27; : snakepos.x =-1;snakepos.y =0;break; case &#x27;S&#x27; : snakepos.x =0;snakepos.y =1;break; case &#x27;W&#x27;: snakepos.x =0;snakepos.y =-1;break; &#125; Update12345678910111213141516head.x+=snakepos.x;head.y+=snakepos.y;for(auto it:++snake.begin();it!=snake.end();++it)//cheak whether snake&#x27;s head overlaps with its body if (it-&gt;x==head.x&amp;&amp;it-&gt;y==head.y) return;if(head.x==food.x&amp;&amp;head.y==food.y) &#123; food.x=rand()%(WIDTH-2)+1; food.y=rand()%(HEIGHT-2)+1; score+=1 &#125; else snake.pop_back();if(head.x &lt;1||head.x&gt;=WIDTH-1||head.y&lt;1||head.y&gt;=HEIGHT-1) return;snake.push_front(head);//update Draw1234567891011121314151617181920212223for(int n=0;n&lt;WIDTH;++n)&#123; for(int m=0;m&lt;HEIGHT;++m) if(n==0||n==WIDTH-1||m==0||m==HEIGHT-1) printf(&quot;#&quot;);//border else &#123; bool print = false; for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); print = true; &#125; if(!print) printf(&quot; &quot;); if(food.x==n&amp;&amp;food.y==m) printf(&quot;F&quot;); &#125; printf(&quot;\\n&quot;);&#125;Sleep(100)//随便system(&quot;cls&quot;)//清屏 如果不用print来判断,而用m+=1(如下)将蛇的位置带过会出现向左向右蛇身数目不一致123456789...for(auto&amp; it:snake) if(it.x==n&amp;&amp;it.y==m) &#123; printf(&quot;O&quot;); ++m; &#125;printf(&quot; &quot;);... result12OOO//向左 O O//向右 ALL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;conio.h&gt;#include &lt;Windows.h&gt;#include &lt;random&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;time.h&gt;//the active placeconst int WIDTH = 60;const int HEIGHT = 30;int score = 0;struct position&#123; int x, y; position(int x = 0, int y = 0) :x(x), y(y) &#123;&#125;;&#125;;std::list&lt;position&gt; snake; //the body of snakeposition food;position snakpos;position head;bool Ismove = true;void InitGame();void GameLoop();int main()&#123; InitGame(); GameLoop(); printf(&quot;YOUR SCORE IS:%d&quot;, score); Sleep(2000); return 0;&#125;void InitGame()&#123; std::srand(time(NULL)); snake.push_back(position(rand() % (WIDTH-2)+1,rand()%(HEIGHT-2)+1));//start place //food food.x = rand() % (WIDTH-2)+1; food.y = rand() % (HEIGHT-2)+1; snakpos.x = 1; snakpos.y = 0; head = snake.front();&#125;void GameLoop()&#123; while (Ismove) &#123; //handle player&#x27;s operation if(_kbhit()) switch (_getch()) &#123; case &#x27;a&#x27;: snakpos.x = -1; snakpos.y = 0; break; case &#x27;d&#x27;: snakpos.x = 1; snakpos.y = 0; break; case &#x27;w&#x27;: snakpos.y = -1; snakpos.x = 0; break; case &#x27;s&#x27;: snakpos.y = 1; snakpos.x = 0; break; case &#x27;r&#x27;:Ismove = false; break; &#125; head.x += snakpos.x; head.y += snakpos.y; //event if (head.x &lt;= 1 || head.y &lt; 1 || head.x &gt; WIDTH-1 || head.y &gt;= HEIGHT-1) &#123; printf(&quot;GAME OVER\\n&quot;); return; &#125; for (auto it = ++snake.begin(); it != snake.end(); ++it) &#123; if (it-&gt;x == head.x &amp;&amp; it-&gt;y == head.y) &#123; printf(&quot;GAME OVER\\n&quot;); return; &#125; &#125; if (head.x == food.x &amp;&amp; head.y == food.y) &#123; food.x = rand() % (WIDTH-2)+1; food.y = rand() % (HEIGHT-2)+1; score += 1; &#125; else snake.pop_back(); snake.push_front(head); //draw for (int y = 0; y &lt; HEIGHT; ++y) &#123; for (int x = 0; x &lt; WIDTH; ++x) &#123; if (y == 0 || y == HEIGHT-1||x == 0 || x == WIDTH-1) printf(&quot;#&quot;); else if (food.x==x &amp;&amp; food.y==y) &#123; printf(&quot;F&quot;); &#125; else &#123; bool ISSNAKE = false; for (auto&amp; it : snake) &#123; if (it.x == x &amp;&amp; it.y == y) &#123; printf(&quot;O&quot;); ISSNAKE = true; //break; &#125; &#125; if (ISSNAKE==false) &#123; printf(&quot; &quot;); &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; Sleep(100); system(&quot;cls&quot;); &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"Game","slug":"C-C/Game","permalink":"https://linikc.github.io/categories/C-C/Game/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"}],"author":"Linik"},{"title":"OpenCV Learning","slug":"OpenCV-Learning","date":"2023-10-05T13:45:23.000Z","updated":"2024-08-17T06:37:41.237Z","comments":true,"path":"2023/10/05/OpenCV-Learning/","link":"","permalink":"https://linikc.github.io/2023/10/05/OpenCV-Learning/","excerpt":"","text":"配置: include目录{ include; opencv2; } lib目录{ lib(x64); } Linker{ opencv_world480d.lib; opencv_world480.lib; } Basic显示图像123456789101112131415161718#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;std::string Path = &quot;./test.jpg&quot;;//相对路径int main()&#123; cv::Mat scr; src = cv::imread(Path,IMREAD_COLOR); if(scr.empty()) &#123; std::cout&lt;&lt;&quot;Can&#x27;t open file:&quot;&lt;&lt;Path&lt;&lt;&quot; Maybe it is not exist&quot;&lt;&lt;std::endl; return -1; &#125; cv::imshow(&quot;test&quot;,scr); cv::waitKey(0); cv::destroyAllWindows(); return 0;&#125; 123456789101112131415cv::imread&#123; IMREAD_UNCHANGED = -1, //如果设置，则返回的数据带有alpha通道（R,G,B,A 四个通道），否则没有alpha通道 IMREAD_GRAYSCALE = 0, //如果设置，则将图像转换为单通道[灰度图像] IMREAD_COLOR = 1, //如果设置，则将图像转换成3通道BGR彩色图像 IMREAD_ANYDEPTH = 2, //如果设置，则在输入具有相应深度时返回16位/32位图像，否则将其转换为8位 IMREAD_ANYCOLOR = 4, //如果设置，则图像可能以任何颜色格式读取 IMREAD_LOAD_GDAL = 8, //如果设置，使用gdal驱动程序加载图像 IMREAD_REDUCED_GRAYSCALE_2 = 16, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/2 IMREAD_REDUCED_COLOR_2 = 17, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/2 IMREAD_REDUCED_GRAYSCALE_4 = 32, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/4 IMREAD_REDUCED_COLOR_4 = 33, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/4 IMREAD_REDUCED_GRAYSCALE_8 = 64, //如果设置，总是将图像转换为单通道灰度图像且图像大小减少1/8 IMREAD_REDUCED_COLOR_8 = 65, //如果设置，总是将图像转换为3通道BGR彩色图像且图像大小减少1/8 IMREAD_IGNORE_ORIENTATION = 128 //如果设置，不会根据EXIF的方向标志旋转图像&#125;; 12345678910111213cv::imshow&#123;8U //如果图像数据类型是8U（8位无符号），则直接显示.16U //如果图像数据类型是16U（16位无符号）或32S（32位有符号整数），则imshow函数内部会自动将每个像素值除以256并显示，即将原图像素值的范围由[0~255*256]映射到[0~255]/*scr1.convertTo(scr2,CV_16U);8U-&gt;16Uscr2.convertTo(scr3,CV_16U,256);16U-&gt;8U**/32F //如果图像数据类型是32F（32位浮点数）或64F（64位浮点数），则imshow函数内部会自动将每个像素值乘以255并显示，即将原图像素值的范围由[0~1]映射到[0~255]（注意：原图像素值必须要归一化）/*scr1.converTo(scr2,CV_32F);normalize(scr2,scr3,0,1,NORM_MINMAX);32F-&gt;8U(lighter)*/&#125;; 调整亮度Formula增益变量 Code123456789101112131415161718192021int alpha=1.5,beta=100; ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type());int length = OrginalPic.rows;int width = OrginalPic.cols;for (int row = 0; row &lt; length; row++) for(int col=0;col&lt;width;col++) if (OrginalPic.channels() == 1) &#123; float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); &#125; else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125;cv::imshow(&quot;Convert&quot;, ConvertPic); Explain:1ConvertPic = cv::Mat::zeros(OrginalPic.size(),OrginalPic.type()); 创建新的空白的图片(size,type一样) 单通道12float v = OrginalPic.at&lt;uchar&gt;(row, col); ConvertPic.at&lt;uchar&gt;(row, col) = cv::saturate_cast&lt;uchar&gt;(v * alpha + beta); 获取像素点灰度(v)将原图的像素点乘以alpha，再加上beta，然后将结果赋值给新图片的像素点cv::saturate_cast 无符号整数&amp;小于255 BGR三通道123456789else if (OrginalPic.channels()==3) &#123; int b = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[0]; int g = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[1]; int r = OrginalPic.at&lt;cv::Vec3b&gt;(row, col)[2]; ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[0] = cv::saturate_cast&lt;uchar&gt;(b * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[1] = cv::saturate_cast&lt;uchar&gt;(g * alpha + beta); ConvertPic.at&lt;cv::Vec3b&gt;(row, col)[2] = cv::saturate_cast&lt;uchar&gt;(r * alpha + beta); &#125; BGR三元素分别进行运算再赋值到新像素点","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"OpenCV","slug":"C-C/OpenCV","permalink":"https://linikc.github.io/categories/C-C/OpenCV/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}],"author":"Linik"}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/categories/C-C/"},{"name":"EasyX","slug":"C-C/EasyX","permalink":"https://linikc.github.io/categories/C-C/EasyX/"},{"name":"Win32","slug":"C-C/Win32","permalink":"https://linikc.github.io/categories/C-C/Win32/"},{"name":"Game","slug":"C-C/Game","permalink":"https://linikc.github.io/categories/C-C/Game/"},{"name":"SDL2","slug":"C-C/SDL2","permalink":"https://linikc.github.io/categories/C-C/SDL2/"},{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/categories/BF/"},{"name":"OpenCV","slug":"C-C/OpenCV","permalink":"https://linikc.github.io/categories/C-C/OpenCV/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://linikc.github.io/tags/C-C/"},{"name":"EasyX","slug":"EasyX","permalink":"https://linikc.github.io/tags/EasyX/"},{"name":"Win32","slug":"Win32","permalink":"https://linikc.github.io/tags/Win32/"},{"name":"Game","slug":"Game","permalink":"https://linikc.github.io/tags/Game/"},{"name":"SDL2","slug":"SDL2","permalink":"https://linikc.github.io/tags/SDL2/"},{"name":"BF","slug":"BF","permalink":"https://linikc.github.io/tags/BF/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://linikc.github.io/tags/OpenCV/"}]}